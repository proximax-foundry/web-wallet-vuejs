import{B as T,z as u,a9 as H,n as b,w as m,H as P,W as w,S}from"./index-d1f9f200.js";const o=class{static addZeros(n,t=0){let a;if(n>0){let s;if(t===0)s=this.addDecimals(n),a=`0${s}`;else{const r=t.toString().replace(/,/g,"").split(".");if(r.length<2)s=this.addDecimals(n);else{const e=r[1].split("");s=this.addDecimals(n-e.length,r[1])}a=`${r[0]}${s}`}}else a=t;return a}static addDecimals(n,t="0"){const a="0";if(t==="0")for(let s=0;s<n-1;s++)t+=a;else for(let s=0;s<n;s++)t+=a;return t}};o.createAssetTransaction=(c,n,t,a,s,r)=>{const e=T.buildTxn.mosaicDefinition(c,t,a,s,r?u.UInt64.fromUint(o.calculateDuration(r)):void 0),l=e.toAggregateV1(c);let d=u.MosaicSupplyType.Increase;const g=T.buildTxn.buildMosaicSupplyChange(e.mosaicId,d,u.UInt64.fromUint(o.addZeros(s,n))).toAggregateV1(c);return T.buildTxn.aggregateComplete([l,g])};o.assetSupplyChangeTransaction=(c,n,t,a)=>{const s=T.buildTxn;let r=n=="increase"?u.MosaicSupplyType.Increase:u.MosaicSupplyType.Decrease;return s.buildMosaicSupplyChange(new u.MosaicId(c),r,u.UInt64.fromUint(o.addZeros(a,t)))};o.linkAssetToNamespaceTransaction=(c,n,t)=>{const a=T.buildTxn;let s;return s=t=="link"?u.AliasActionType.Link:u.AliasActionType.Unlink,a.assetAlias(s,new u.NamespaceId(n),new u.MosaicId(c))};o.createAssetTransactionFee=(c,n,t,a,s,r)=>o.createAssetTransaction(c,n,t,a,s,r).maxFee.compact();o.getMosaicSupplyChangeTransactionFee=(c,n,t,a)=>o.assetSupplyChangeTransaction(c,n,t,a).maxFee.compact();o.getLinkAssetToNamespaceTransactionFee=(c,n,t)=>o.linkAssetToNamespaceTransaction(c,n,t).maxFee.compact();o.calculateDuration=c=>{let n=new H(b.chainNetworkName);n.init();let t=parseInt(n.blockGenerationTargetTime),a=60*60*24/t;return Math.floor(c*a)};o.getOwnedAssets=c=>{const n=[],t=m.currentLoggedInWallet.accounts.find(e=>e.address===c),a=m.currentLoggedInWallet.others.find(e=>e.address===c),s=t?t.assets.filter(e=>e.creator===t.publicKey):[],r=a?a.assets.filter(e=>e.creator===a.publicKey):[];return s.length>0&&s.forEach(e=>{n.push({label:e.idHex+" > "+P.amountFormatterSimple(e.amount,e.divisibility),value:e.idHex})}),r.length>0&&r.forEach(e=>{n.push({label:e.idHex+" > "+P.amountFormatterSimple(e.amount,e.divisibility),value:e.idHex})}),n};o.getOwnedAssetsPermutable=c=>{const n=[],t=m.currentLoggedInWallet.accounts.find(e=>e.address===c),a=m.currentLoggedInWallet.others.find(e=>e.address===c),s=t?t.assets.filter(e=>e.creator===t.publicKey&&e.supplyMutable===!0):[],r=a?a.assets.filter(e=>e.creator===a.publicKey&&e.supplyMutable===!0):[];return s.length>0&&s.forEach(e=>{n.push({label:e.idHex+" > "+P.amountFormatterSimple(e.amount,e.divisibility),value:e.idHex})}),r.length>0&&r.forEach(e=>{n.push({label:e.idHex+" > "+P.amountFormatterSimple(e.amount,e.divisibility),value:e.idHex})}),n};o.getSenderAccount=(c,n)=>{const t=u.Address.createFromRawAddress(c),a=m.currentLoggedInWallet.accounts.find(l=>l.address==t.plain()),s=w.createPassword(n);let r=w.decryptPrivateKey(s,a.encrypted,a.iv);return u.Account.createFromPrivateKey(r,T.networkType,1)};o.createAsset=(c,n,t,a,s,r,e,l)=>{let d=o.createAssetTransaction(t,a,s,r,e,l),i=o.getSenderAccount(c,n).preV2Sign(d,b.currentNetworkProfile.generationHash);S.announceTransaction(i)};o.createAssetMultiSig=(c,n,t,a,s,r,e,l,d)=>{const g=T.buildTxn.mosaicDefinition(t,s,r,e,d?u.UInt64.fromUint(o.calculateDuration(d)):void 0),i=g.toAggregateV1(t);let p;p=u.MosaicSupplyType.Increase;const A=T.buildTxn.buildMosaicSupplyChange(g.mosaicId,p,u.UInt64.fromUint(o.addZeros(e,a))).toAggregateV1(t),h=o.getSenderAccount(c,n),y=[i,A],x=T.buildTxn.aggregateBonded(y,l),f=h.preV2Sign(x,b.currentNetworkProfile.generationHash);let k=S.lockFundTx(f),N=h.preV2Sign(k,b.currentNetworkProfile.generationHash);S.announceLF_AND_addAutoAnnounceABT(N,f)};o.changeAssetSupply=(c,n,t,a,s,r)=>{let e=o.assetSupplyChangeTransaction(t,a,s,r),d=o.getSenderAccount(c,n).preV2Sign(e,b.currentNetworkProfile.generationHash);S.announceTransaction(d)};o.changeAssetSupplyMultiSig=(c,n,t,a,s,r,e,l)=>{let d=T.buildTxn,g=o.assetSupplyChangeTransaction(t,a,s,r);const i=o.getSenderAccount(c,n),p=m.currentLoggedInWallet.accounts.find(v=>v.address===e),A=m.currentLoggedInWallet.others.find(v=>v.address===e),h=p?p.publicKey:A.publicKey,y=u.PublicAccount.createFromPublicKey(h,T.networkType),x=[g.toAggregateV1(y)],f=d.aggregateBonded(x,l),k=i.preV2Sign(f,b.currentNetworkProfile.generationHash);let N=S.lockFundTx(k),I=i.preV2Sign(N,b.currentNetworkProfile.generationHash);S.announceLF_AND_addAutoAnnounceABT(I,k)};o.linkedNamespaceToAsset=(c,n,t,a,s)=>{const r=o.linkAssetToNamespaceTransaction(t,a,s);let l=o.getSenderAccount(c,n).preV2Sign(r,b.currentNetworkProfile.generationHash);S.announceTransaction(l)};o.linkedNamespaceToAssetMultiSig=(c,n,t,a,s,r,e)=>{let l=T.buildTxn;const d=o.linkAssetToNamespaceTransaction(t,a,s),g=o.getSenderAccount(c,n),i=m.currentLoggedInWallet.accounts.find(I=>I.address===r),p=m.currentLoggedInWallet.others.find(I=>I.address===r),A=i?i.publicKey:p.publicKey,h=u.PublicAccount.createFromPublicKey(A,T.networkType),y=[d.toAggregateV1(h)],x=l.aggregateBonded(y,e),f=g.preV2Sign(x,b.currentNetworkProfile.generationHash);let k=S.lockFundTx(f),N=g.preV2Sign(k,b.currentNetworkProfile.generationHash);S.announceLF_AND_addAutoAnnounceABT(N,f)};o.listActiveNamespacesToLink=(c,n,t)=>{const a=m.currentLoggedInWallet.accounts.find(i=>i.address===n),s=a?a.namespaces.filter(i=>i.active===!0):[],r=m.currentLoggedInWallet.others.find(i=>i.address===n),e=r?r.namespaces.filter(i=>i.active===!0):[];let l,d;s.length>0?(l=s.length,d=s):(l=e.length,d=e);let g=[];return l>0&&(d.forEach(i=>{console.log(i);const p=i.name.split(".");let A,h="",y="";if(i.linkedId!=""){let x,f;switch(i.linkType){case 1:x="Asset",f=i.linkedId,A=t=="link";break;case 2:x="Address",f=P.createAddress(i.linkedId).pretty(),A=!0;break}h=i.name+" (Linked to "+x+") - "+f,y=i.name}else A=t!="link",h=i.name,y=i.name;t=="link"&&g.push({value:y,label:h,disabled:A,level:p}),t=="unlink"&&i.linkedId==c&&g.push({value:y,label:h,disabled:A,level:p})}),g.sort((i,p)=>i.label>p.label?1:i.label<p.label?-1:0),g.sort((i,p)=>i.level>p.level?1:i.level<p.level?-1:0)),g};let C=o;export{C as A};
