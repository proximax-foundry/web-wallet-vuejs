import{w as m,E as r,B as t,W as T,n as w,P as E}from"./index-58a8249b.js";const B=class{static verifyContactPublicKey(n){const i="0000000000000000000000000000000000000000000000000000000000000000";return new Promise(c=>{T.getAccInfo(n).then(a=>{a.publicKey==i?(console.warn("The receiver's public key is not valid for sending encrypted messages"),c({status:!1,publicKey:a.publicKey})):c({status:!0,publicKey:a.publicKey})},a=>{console.warn("Err: "+a),c({status:!1,publicKey:""})})})}static async convertAccount(n,i,c,o,a){const u=m.currentLoggedInWallet;if(!u)throw new Error("Service unavailable");const d=T.verifyWalletPassword(u.name,w.chainNetworkName,a);if(!d)return d;const l=[],g=u.accounts.find(p=>p.name===o);if(!g)throw new Error("Account not found");const e=T.decryptPrivateKey(new t.Password(a),g.encrypted,g.iv),f=t.Account.createFromPrivateKey(e,r.networkType,1);if(!r.chainAPI)throw new Error("Service unavailable");let s=null;for(const p of n){if(p.length==64)s=t.PublicAccount.createFromPublicKey(p,r.networkType);else if(p.length==40||p.length==46){const k=t.Address.createFromRawAddress(p);try{const M=await r.chainAPI.accountAPI.getAccountInfo(k);s=t.PublicAccount.createFromPublicKey(M.publicKey,r.networkType)}catch(M){console.log(M)}}s&&l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,s))}if(!r.buildTxn)throw new Error("Service unavailable");const A=r.buildTxn,P=A.modifyMultisigAccountBuilder().minApprovalDelta(i).minRemovalDelta(c).modifications(l).build(),K=A.aggregateBondedBuilder().innerTransactions([P.toAggregateV1(f.publicAccount)]).build();if(!w.currentNetworkProfile)throw new Error("Service unavailable");const I=f.preV2Sign(K,w.currentNetworkProfile.generationHash),y=E.lockFundTx(I),v=f.preV2Sign(y,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(v,I),d}static getAggregateBondedTransactions(n){return T.getAggregateBondedTransactions(n)}static async onPartial(n){const i=await B.getAggregateBondedTransactions(n);if(i.length){for(const c of i)for(let o=0;o<c.innerTransactions.length;o++)if(c.innerTransactions[o].signer.publicKey===n.publicKey)return!0}return!1}static getMultisigAccountGraphInfo(n){return T.getMultisigAccGraphInfo(t.Address.createFromRawAddress(n))}static checkIsMultiSig(n){const i=m.currentLoggedInWallet;if(!i)throw new Error("Service unavailable");const c=i.accounts.find(o=>o.address===n)||i.others.find(o=>o.address===n);if(!c)throw new Error("Account not found");return c.getDirectParentMultisig().length>0}static checkHasMultiSig(n){const i=m.currentLoggedInWallet;if(!i)throw new Error("Service unavailable");const c=i.accounts.find(o=>o.address===n)||i.others.find(o=>o.address===n);if(!c)throw new Error("Account not found");return c.multisigInfo.filter(o=>o.level==-1).length>0}static getCosignerInWallet(n){if(!m.currentLoggedInWallet)throw new Error("Service unavailable");if(!w.currentNetworkProfileConfig)throw new Error("Service unavailable");const i=m.currentLoggedInWallet.accounts.map(e=>({publicKey:e.publicKey,isMultisig:!!e.getDirectParentMultisig().length,multisigInfo:e.multisigInfo})),c=m.currentLoggedInWallet.others.filter(e=>e.type==="MULTISIG").map(e=>({publicKey:e.publicKey,isMultisig:!0,multisigInfo:e.multisigInfo})),o=i.concat(c),a=o.find(e=>e.publicKey==n);if(!a)throw new Error("Account not found");const u=[];o.forEach(e=>{!e.isMultisig&&e.multisigInfo.filter(f=>f.level==-1).length>0&&u.push(e)});const d=w.currentNetworkProfileConfig.maxMultisigDepth;if(!d)throw new Error("Service unavailable");const l=[];for(let e=1;e<=d;e++)a.multisigInfo.filter(s=>s.level==e).forEach(s=>{u.forEach(A=>{A.publicKey==s.publicKey&&l.push(s.publicKey)})});let g=!1;return l.length>0&&(g=!0),{hasCosigner:g,cosignerList:l}}static async modifyMultisigAccount(n,i,c,o,a,u,d){const l=m.currentLoggedInWallet;if(!l)throw new Error("Service unavailable");if(!r.chainAPI)throw new Error("Service unavailable");if(!T.verifyWalletPassword(l.name,w.chainNetworkName,d))return!1;const g=[],e=[];for(const[h,b]of i.entries()){if(b.length==64)e[h]=t.PublicAccount.createFromPublicKey(b,r.networkType);else if(b.length==40||b.length==46){const N=t.Address.createFromRawAddress(b);try{const S=await r.chainAPI.accountAPI.getAccountInfo(N);e[h]=t.PublicAccount.createFromPublicKey(S.publicKey,r.networkType)}catch(S){console.log(S)}}g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,e[h]))}c.forEach((h,b)=>{e[i.length+b]=t.PublicAccount.createFromPublicKey(h,r.networkType),g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,e[i.length+b]))});const f=u.multisigInfo.find(h=>h.level===0);if(!f)throw new Error("Account not found");const s=o-f.minApproval,A=a-f.minRemoval;if(!r.buildTxn)throw new Error("Service unavailable");const P=r.buildTxn,K=P.modifyMultisigAccountBuilder().minApprovalDelta(s).minRemovalDelta(A).modifications(g).build(),I=t.PublicAccount.createFromPublicKey(u.publicKey,r.networkType),y=P.aggregateBondedBuilder().innerTransactions([K.toAggregateV1(I)]).build(),v=l.accounts.find(h=>h.publicKey==n);if(!v)throw new Error("Account not found");if(!w.currentNetworkProfile)throw new Error("Service unavailable");const p=T.decryptPrivateKey(new t.Password(d),v.encrypted,v.iv),k=t.Account.createFromPrivateKey(p,r.networkType,1),M=k.preV2Sign(y,w.currentNetworkProfile.generationHash),F=E.lockFundTx(M),C=k.preV2Sign(F,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(C,M),!0}};let x=B;x.getAggregateFee=(n,i,c,o,a)=>{const u=m.currentLoggedInWallet;if(!r.chainAPI||!u)throw new Error("Service unavailable");const d=u.accounts.find(y=>y.publicKey==n)||u.others.find(y=>y.publicKey==n);if(!d)throw new Error("Account not found");const l=[];for(const y of i)l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,t.PublicAccount.createFromPublicKey("0".repeat(64),r.networkType)));const g=[];if(a&&a.forEach((y,v)=>{g[i.length+v]=t.PublicAccount.createFromPublicKey(y,r.networkType),l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,g[i.length+v]))}),!r.buildTxn)throw new Error("Service unavailable");const e=r.buildTxn,f=t.PublicAccount.createFromPublicKey(n,r.networkType),s=d.multisigInfo.find(y=>y.level===0);if(!s)throw new Error("Account not found");const A=c-s.minApproval,P=o-s.minRemoval,K=e.modifyMultisigAccountBuilder().minApprovalDelta(A).minRemovalDelta(P).modifications(l).build();return e.aggregateBondedBuilder().innerTransactions([K.toAggregateV1(f)]).build().maxFee.compact()/Math.pow(10,r.nativeToken.divisibility)};export{x as M};
