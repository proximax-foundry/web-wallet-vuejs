import{a6 as D,W as y,w as l,x as c,A as d,n as p,B as A,G as F}from"./index-ac085045.js";const S=async r=>{const n="0000000000000000000000000000000000000000000000000000000000000000";return!!await new Promise((t,a)=>{y.getAccInfo(r).then(i=>{i.publicKey===n?(console.warn("The receiver's public key is not valid for sending encrypted messages"),t(!0)):t(!1)}).catch(i=>{a("Err: "+i)})})},V=(r,n)=>{const e=n!=null&&n!==""?n.split("-").join(""):"";let s=!1,t="";return e!=null&&e.length===40?y.verifyNetworkAddressEqualsNetwork(r,n.toUpperCase())?s=!0:(s=!1,t="Recipient Address Network unsupported"):s=!1,{isPassed:s,errMessage:t}},R=r=>{const n=l.currentLoggedInWallet;let e=!0;return r=c.Address.createFromRawAddress(r).plain(),n.contacts!=null&&(e=!!n.contacts.find(s=>s.address==r)),!!(e||n.accounts.find(s=>s.address===r)||n.others.find(s=>s.address===r))},I=r=>{if(!l.currentLoggedInWallet)return[];let n=[];return l.currentLoggedInWallet.others.find(e=>e.address===r)?n=l.currentLoggedInWallet.others.find(e=>e.address==r).namespaces.filter(e=>e.active===!0):l.currentLoggedInWallet.accounts.find(e=>e.address===r)&&(n=l.currentLoggedInWallet.accounts.find(e=>e.address==r).namespaces.filter(e=>e.active===!0)),n},C=()=>{if(!l.currentLoggedInWallet)return[];const r=l.currentLoggedInWallet;let n=[];return r.accounts.forEach(e=>{let s=c.Address.createFromRawAddress(e.address).pretty();n.push({value:s,label:e.name+" - Internal Account "})}),r.contacts!=null&&r.contacts.forEach(e=>{let s=c.Address.createFromRawAddress(e.address).pretty();n.push({value:s,label:e.name+" - Contact From Address Book"})}),n},M=(r,n)=>{let e=[],s=I(r);return s.length>0&&(s.forEach(t=>{const a=t.name.split(".");let o,i,u,g;t.linkedId!=""?(o=n=="Link",t.linkType==1?(i="Asset",u=t.linkedId,o=!0):t.linkType==2?(i="Address",u=c.Address.createFromRawAddress(t.linkedId).pretty()):(i="Address",u=c.Address.createFromRawAddress(t.linkedId).pretty(),o=!0),g=t.name+" (Linked to "+i+") - "+u):t.linkedId==""&&(o=n!="Link",g=t.name+"(Current unused namespace)"),e.push({value:t.name,label:g,level:a,disabled:o})}),e.sort((t,a)=>t.label>a.label?1:t.label<a.label?-1:0),e.sort((t,a)=>t.level>a.level?1:t.level<a.level?-1:0)),e},U=r=>{const n=l.currentLoggedInWallet.accounts.find(o=>o.address==r),e=l.currentLoggedInWallet.others.find(o=>o.address==r);let s=!1;const t=n?n.getDirectParentMultisig():[],a=e?e.getDirectParentMultisig():[];return(t.length>0||a.length>0)&&(s=!0),s},L=(r,n)=>{const e=c.Address.createFromRawAddress(r),s=l.currentLoggedInWallet.accounts.find(i=>i.address==e.plain()),t=y.createPassword(n),a=y.decryptPrivateKey(t,s.encrypted,s.iv);return c.Account.createFromPrivateKey(a,d.networkType,1)},x=(r,n,e)=>{const s=d.buildTxn,t=n=="Link"?c.AliasActionType.Link:c.AliasActionType.Unlink,a=new c.NamespaceId(r),o=c.Address.createFromRawAddress(e);return s.addressAliasBuilder().actionType(t).namespaceId(a).address(o).build()},K=(r,n)=>d.buildTxn.accountLinkBuilder().remoteAccountKey(r).linkAction(n).build(),H=(r,n,e,s)=>{const t=x(e,s,n);if(r){let a="0".repeat(64);return d.buildTxn.aggregateBonded([t.toAggregateV1(c.PublicAccount.createFromPublicKey(a,d.networkType))]).maxFee.compact()}else return t.maxFee.compact()},_=(r,n,e,s,t,a,o,i)=>{const u=x(t,a,o),g=e.address,T=L(g,s);let k;if(!n)k=T.preV2Sign(u,p.currentNetworkProfile.generationHash),A.announceTransaction(k);else{let b=c.PublicAccount.createFromPublicKey(e.publicKey,d.networkType),m=[u.toAggregateV1(b)];const w=A.aggregateBondedTx(m,i),f=l.currentLoggedInWallet.accounts.find(W=>W.publicKey===r);let h=y.decryptPrivateKey(new c.Password(s),f.encrypted,f.iv),v=c.Account.createFromPrivateKey(h,d.networkType,1);const P=v.preV2Sign(w,p.currentNetworkProfile.generationHash),B=A.lockFundTx(P),N=v.preV2Sign(B,p.currentNetworkProfile.generationHash);A.announceLF_AND_addAutoAnnounceABT(N,P)}},$=(r,n,e,s,t,a,o)=>{let i=K(t,a),u;if(n){let g=c.PublicAccount.createFromPublicKey(e.publicKey,d.networkType),T=[i.toAggregateV1(g)];const k=A.aggregateBondedTx(T,o),b=l.currentLoggedInWallet.accounts.find(P=>P.publicKey===r);let m=y.decryptPrivateKey(new c.Password(s),b.encrypted,b.iv),w=c.Account.createFromPrivateKey(m,d.networkType,1);const f=w.preV2Sign(k,p.currentNetworkProfile.generationHash);u=f;const h=A.lockFundTx(f),v=w.preV2Sign(h,p.currentNetworkProfile.generationHash);A.announceLF_AND_addAutoAnnounceABT(v,f)}else{const g=e.address;u=L(g,s).preV2Sign(i,p.currentNetworkProfile.generationHash),A.announceTransaction(u)}return u},j=r=>{let n=d.buildTxn,e=c.LinkAction.Link,s="0".repeat(64);const t=K(s,e);if(r){let a=[t.toAggregateV1(c.PublicAccount.createFromPublicKey(s,d.networkType))];return n.aggregateBonded(a).maxFee.compact()/Math.pow(10,d.nativeToken.divisibility)}else return t.maxFee.compact()/Math.pow(10,d.nativeToken.divisibility)},q=async r=>{let n=F.buildAPIEndpoint(p.selectedAPIEndpoint,p.currentNetworkProfile.httpPort);const e=await fetch(`${n}/account/${r}`);let s=c.Address.createFromRawAddress(r),t;if(e.status==200){let a=await F.getAccountInfo(s);a.linkedAccountKey=="0".repeat(64)&&(a.accountType==3?t=!0:t=!1)}else e.status==404?t=!0:t=!1;return t},z=D({checkAvailableContact:R,verifyAddress:V,verifyPublicKey:S,getNamespaceListByAddress:I,getContact:C,getMultisig:U,namespaceOption:M,getLinkNamespaceToAddressTransactionFee:H,linkNamespaceToAddress:_,createDelegateTransaction:$,getValidAccount:q,getDelegateFee:j});export{z as a};
