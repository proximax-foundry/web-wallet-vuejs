var G=Object.defineProperty;var H=(n,t,i)=>t in n?G(n,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[t]=i;var M=(n,t,i)=>(H(n,typeof t!="symbol"?t+"":t,i),i),R=(n,t,i)=>{if(!t.has(n))throw TypeError("Cannot "+i)};var s=(n,t,i)=>(R(n,t,"read from private field"),i?i.call(n):t.get(n)),c=(n,t,i)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,i)},L=(n,t,i,e)=>(R(n,t,"write to private field"),e?e.call(n,i):t.set(n,i),i);var l=(n,t,i)=>(R(n,t,"access private method"),i);import{p as J,d as K,a as U,b as p,c as Q}from"./address-ae442d6a.js";import{g as j,a as W,t as X,f as z,m as q}from"./icon-connected-93466ffa.js";const Y=BigInt(-1),d=BigInt(0),S=BigInt(1),O=BigInt(5),x={};let F="0000";for(;F.length<80;)F+=F;function I(n){let t=F;for(;t.length<n;)t+=t;return BigInt("1"+t.substring(0,n))}function T(n,t,i){const e=BigInt(t.width);if(t.signed){const r=S<<e-S;p(i==null||n>=-r&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n>d?n=z(q(n,e),e):n=-z(q(-n,e),e)}else{const r=S<<e;p(i==null||n>=0&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n=(n%r+r)%r&r-S}return n}function _(n){typeof n=="number"&&(n=`fixed128x${n}`);let t=!0,i=128,e=18;if(typeof n=="string"){if(n!=="fixed")if(n==="ufixed")t=!1;else{const u=n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);U(u,"invalid fixed format","format",n),t=u[1]!=="u",i=parseInt(u[2]),e=parseInt(u[3])}}else if(n){const u=n,a=(f,B,D)=>u[f]==null?D:(U(typeof u[f]===B,"invalid fixed format ("+f+" not "+B+")","format."+f,u[f]),u[f]);t=a("signed","boolean",t),i=a("width","number",i),e=a("decimals","number",e)}U(i%8===0,"invalid FixedNumber width (not byte aligned)","format.width",i),U(e<=80,"invalid FixedNumber decimals (too large)","format.decimals",e);const r=(t?"":"u")+"fixed"+String(i)+"x"+String(e);return{signed:t,width:i,decimals:e,name:r}}function tt(n,t){let i="";n<d&&(i="-",n*=Y);let e=n.toString();if(t===0)return i+e;for(;e.length<=t;)e=F+e;const r=e.length-t;for(e=e.substring(0,r)+"."+e.substring(r);e[0]==="0"&&e[1]!==".";)e=e.substring(1);for(;e[e.length-1]==="0"&&e[e.length-2]!==".";)e=e.substring(0,e.length-1);return i+e}var m,o,h,b,N,g,w,y,$,A,P,C,Z,E,k;const v=class v{constructor(t,i,e){c(this,b);c(this,g);c(this,y);c(this,A);c(this,C);c(this,E);M(this,"format");c(this,m,void 0);c(this,o,void 0);c(this,h,void 0);M(this,"_value");J(t,x,"FixedNumber"),L(this,o,i),L(this,m,e);const r=tt(i,e.decimals);K(this,{format:e.name,_value:r}),L(this,h,I(e.decimals))}get signed(){return s(this,m).signed}get width(){return s(this,m).width}get decimals(){return s(this,m).decimals}get value(){return s(this,o)}addUnsafe(t){return l(this,y,$).call(this,t)}add(t){return l(this,y,$).call(this,t,"add")}subUnsafe(t){return l(this,A,P).call(this,t)}sub(t){return l(this,A,P).call(this,t,"sub")}mulUnsafe(t){return l(this,C,Z).call(this,t)}mul(t){return l(this,C,Z).call(this,t,"mul")}mulSignal(t){l(this,b,N).call(this,t);const i=s(this,o)*s(t,o);return p(i%s(this,h)===d,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),l(this,g,w).call(this,i/s(this,h),"mulSignal")}divUnsafe(t){return l(this,E,k).call(this,t)}div(t){return l(this,E,k).call(this,t,"div")}divSignal(t){p(s(t,o)!==d,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),l(this,b,N).call(this,t);const i=s(this,o)*s(this,h);return p(i%s(t,o)===d,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),l(this,g,w).call(this,i/s(t,o),"divSignal")}cmp(t){let i=this.value,e=t.value;const r=this.decimals-t.decimals;return r>0?e*=I(r):r<0&&(i*=I(-r)),i<e?-1:i>e?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=s(this,o);return s(this,o)<d&&(t-=s(this,h)-S),t=s(this,o)/s(this,h)*s(this,h),l(this,g,w).call(this,t,"floor")}ceiling(){let t=s(this,o);return s(this,o)>d&&(t+=s(this,h)-S),t=s(this,o)/s(this,h)*s(this,h),l(this,g,w).call(this,t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const i=this.decimals-t,e=O*I(i-1);let r=this.value+e;const u=I(i);return r=r/u*u,T(r,s(this,m),"round"),new v(x,r,s(this,m))}isZero(){return s(this,o)===d}isNegative(){return s(this,o)<d}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return v.fromString(this.toString(),t)}static fromValue(t,i,e){const r=i==null?0:j(i),u=_(e);let a=W(t,"value");const f=r-u.decimals;if(f>0){const B=I(f);p(a%B===d,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),a/=B}else f<0&&(a*=I(-f));return T(a,u,"fromValue"),new v(x,a,u)}static fromString(t,i){const e=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);U(e&&e[2].length+e[3].length>0,"invalid FixedNumber string value","value",t);const r=_(i);let u=e[2]||"0",a=e[3]||"";for(;a.length<r.decimals;)a+=F;p(a.substring(r.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),a=a.substring(0,r.decimals);const f=BigInt(e[1]+u+a);return T(f,r,"fromString"),new v(x,f,r)}static fromBytes(t,i){let e=X(Q(t,"value"));const r=_(i);return r.signed&&(e=z(e,r.width)),T(e,r,"fromBytes"),new v(x,e,r)}};m=new WeakMap,o=new WeakMap,h=new WeakMap,b=new WeakSet,N=function(t){U(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)},g=new WeakSet,w=function(t,i){return t=T(t,s(this,m),i),new v(x,t,s(this,m))},y=new WeakSet,$=function(t,i){return l(this,b,N).call(this,t),l(this,g,w).call(this,s(this,o)+s(t,o),i)},A=new WeakSet,P=function(t,i){return l(this,b,N).call(this,t),l(this,g,w).call(this,s(this,o)-s(t,o),i)},C=new WeakSet,Z=function(t,i){return l(this,b,N).call(this,t),l(this,g,w).call(this,s(this,o)*s(t,o)/s(this,h),i)},E=new WeakSet,k=function(t,i){return p(s(t,o)!==d,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),l(this,b,N).call(this,t),l(this,g,w).call(this,s(this,o)*s(this,h)/s(t,o),i)};let V=v;const it=["wei","kwei","mwei","gwei","szabo","finney","ether"];function rt(n,t){U(typeof n=="string","value must be a string","value",n);let i=18;if(typeof t=="string"){const e=it.indexOf(t);U(e>=0,"invalid unit","unit",t),i=3*e}else t!=null&&(i=j(t,"unit"));return V.fromString(n,{decimals:i,width:512}).value}export{rt as p};
