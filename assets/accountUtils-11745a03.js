import{aY as W,W as y,w as l,z as c,B as d,n as A,S as p,G as h}from"./index-fa4d404e.js";const D=async r=>{const n="0000000000000000000000000000000000000000000000000000000000000000";return!!await new Promise((t,a)=>{y.getAccInfo(r).then(i=>{i.publicKey===n?(console.warn("The receiver's public key is not valid for sending encrypted messages"),t(!0)):t(!1)}).catch(i=>{a("Err: "+i)})})},S=(r,n)=>{const e=n!=null&&n!==""?n.split("-").join(""):"";let s=!1,t="";return e!=null&&e.length===40?y.verifyNetworkAddressEqualsNetwork(r,n.toUpperCase())?s=!0:(s=!1,t="Recipient Address Network unsupported"):s=!1,{isPassed:s,errMessage:t}},V=r=>{const n=l.currentLoggedInWallet;let e=!0;return r=c.Address.createFromRawAddress(r).plain(),n.contacts!=null&&(e=!!n.contacts.find(s=>s.address==r)),!!(e||n.accounts.find(s=>s.address===r)||n.others.find(s=>s.address===r))},F=r=>{if(!l.currentLoggedInWallet)return[];let n=[];return l.currentLoggedInWallet.others.find(e=>e.address===r)?n=l.currentLoggedInWallet.others.find(e=>e.address==r).namespaces.filter(e=>e.active===!0):l.currentLoggedInWallet.accounts.find(e=>e.address===r)&&(n=l.currentLoggedInWallet.accounts.find(e=>e.address==r).namespaces.filter(e=>e.active===!0)),n},R=()=>{if(!l.currentLoggedInWallet)return[];const r=l.currentLoggedInWallet;let n=[];return r.accounts.forEach(e=>{let s=c.Address.createFromRawAddress(e.address).pretty();n.push({value:s,label:e.name+" - Internal Account "})}),r.contacts!=null&&r.contacts.forEach(e=>{let s=c.Address.createFromRawAddress(e.address).pretty();n.push({value:s,label:e.name+" - Contact From Address Book"})}),n},C=(r,n)=>{let e=[],s=F(r);return s.length>0&&(s.forEach(t=>{const a=t.name.split(".");let o,i,u,g;t.linkedId!=""?(o=n=="Link",t.linkType==1?(i="Asset",u=t.linkedId,o=!0):t.linkType==2?(i="Address",u=c.Address.createFromRawAddress(t.linkedId).pretty()):(i="Address",u=c.Address.createFromRawAddress(t.linkedId).pretty(),o=!0),g=t.name+" (Linked to "+i+") - "+u):t.linkedId==""&&(o=n!="Link",g=t.name+"(Current unused namespace)"),e.push({value:t.name,label:g,level:a,disabled:o})}),e.sort((t,a)=>t.label>a.label?1:t.label<a.label?-1:0),e.sort((t,a)=>t.level>a.level?1:t.level<a.level?-1:0)),e},M=r=>{const n=l.currentLoggedInWallet.accounts.find(o=>o.address==r),e=l.currentLoggedInWallet.others.find(o=>o.address==r);let s=!1;const t=n?n.getDirectParentMultisig():[],a=e?e.getDirectParentMultisig():[];return(t.length>0||a.length>0)&&(s=!0),s},I=(r,n)=>{const e=c.Address.createFromRawAddress(r),s=l.currentLoggedInWallet.accounts.find(i=>i.address==e.plain()),t=y.createPassword(n),a=y.decryptPrivateKey(t,s.encrypted,s.iv);return c.Account.createFromPrivateKey(a,d.networkType,1)},L=(r,n,e)=>{const s=d.buildTxn,t=n=="Link"?c.AliasActionType.Link:c.AliasActionType.Unlink,a=new c.NamespaceId(r),o=c.Address.createFromRawAddress(e);return s.addressAliasBuilder().actionType(t).namespaceId(a).address(o).build()},x=(r,n)=>d.buildTxn.accountLinkBuilder().remoteAccountKey(r).linkAction(n).build(),U=(r,n,e,s)=>{const t=L(e,s,n);if(r){let a="0".repeat(64);return d.buildTxn.aggregateBonded([t.toAggregateV1(c.PublicAccount.createFromPublicKey(a,d.networkType))]).maxFee.compact()}else return t.maxFee.compact()},H=(r,n,e,s,t,a,o)=>{const i=L(t,a,o),u=e.address,g=I(u,s);let T;if(!n)T=g.preV2Sign(i,A.currentNetworkProfile.generationHash),p.announceTransaction(T);else{let k=c.PublicAccount.createFromPublicKey(e.publicKey,d.networkType),P=[i.toAggregateV1(k)];const b=p.aggregateBondedTx(P),f=l.currentLoggedInWallet.accounts.find(N=>N.publicKey===r);let m=y.decryptPrivateKey(new c.Password(s),f.encrypted,f.iv),w=c.Account.createFromPrivateKey(m,d.networkType,1);const v=w.preV2Sign(b,A.currentNetworkProfile.generationHash),K=p.lockFundTx(v),B=w.preV2Sign(K,A.currentNetworkProfile.generationHash);p.announceLF_AND_addAutoAnnounceABT(B,v)}},_=(r,n,e,s,t,a)=>{let o=x(t,a),i;if(n){let u=c.PublicAccount.createFromPublicKey(e.publicKey,d.networkType),g=[o.toAggregateV1(u)];const T=p.aggregateBondedTx(g),k=l.currentLoggedInWallet.accounts.find(v=>v.publicKey===r);let P=y.decryptPrivateKey(new c.Password(s),k.encrypted,k.iv),b=c.Account.createFromPrivateKey(P,d.networkType,1);const f=b.preV2Sign(T,A.currentNetworkProfile.generationHash);i=f;const m=p.lockFundTx(f),w=b.preV2Sign(m,A.currentNetworkProfile.generationHash);p.announceLF_AND_addAutoAnnounceABT(w,f)}else{const u=e.address;i=I(u,s).preV2Sign(o,A.currentNetworkProfile.generationHash),p.announceTransaction(i)}return i},$=r=>{let n=d.buildTxn,e=c.LinkAction.Link,s="0".repeat(64);const t=x(s,e);if(r){let a=[t.toAggregateV1(c.PublicAccount.createFromPublicKey(s,d.networkType))];return n.aggregateBonded(a).maxFee.compact()/Math.pow(10,d.nativeToken.divisibility)}else return t.maxFee.compact()/Math.pow(10,d.nativeToken.divisibility)},j=async r=>{let n=h.buildAPIEndpoint(A.selectedAPIEndpoint,A.currentNetworkProfile.httpPort);const e=await fetch(`${n}/account/${r}`);let s=c.Address.createFromRawAddress(r),t;if(e.status==200){let a=await h.getAccountInfo(s);a.linkedAccountKey=="0".repeat(64)&&(a.accountType==3?t=!0:t=!1)}else e.status==404?t=!0:t=!1;return t},z=W({checkAvailableContact:V,verifyAddress:S,verifyPublicKey:D,getNamespaceListByAddress:F,getContact:R,getMultisig:M,namespaceOption:C,getLinkNamespaceToAddressTransactionFee:U,linkNamespaceToAddress:H,createDelegateTransaction:_,getValidAccount:j,getDelegateFee:$});export{z as a};
