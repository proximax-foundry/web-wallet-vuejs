import{d as t}from"./tsjs-xpx-chain-sdk-84426b6a.js";import{W as T,w as b,A as r,n as w,f as E}from"./index-db436e65.js";const S=class S{static verifyContactPublicKey(n){const i="0000000000000000000000000000000000000000000000000000000000000000";return new Promise(c=>{T.getAccInfo(n).then(a=>{a.publicKey==i?(console.warn("The receiver's public key is not valid for sending encrypted messages"),c({status:!1,publicKey:a.publicKey})):c({status:!0,publicKey:a.publicKey})},a=>{console.warn("Err: "+a),c({status:!1,publicKey:""})})})}static async convertAccount(n,i,c,o,a){const u=b.currentLoggedInWallet;if(!u)throw new Error("Service unavailable");const d=T.verifyWalletPassword(u.name,w.chainNetworkName,a);if(!d)return d;const l=[],g=u.accounts.find(p=>p.name===o);if(!g)throw new Error("Account not found");const e=T.decryptPrivateKey(new t.Password(a),g.encrypted,g.iv),f=t.Account.createFromPrivateKey(e,r.networkType,1);if(!r.chainAPI)throw new Error("Service unavailable");let s=null;for(const p of n){if(p.length==64)s=t.PublicAccount.createFromPublicKey(p,r.networkType);else if(p.length==40||p.length==46){const k=t.Address.createFromRawAddress(p);try{const K=await r.chainAPI.accountAPI.getAccountInfo(k);s=t.PublicAccount.createFromPublicKey(K.publicKey,r.networkType)}catch(K){console.log(K)}}s&&l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,s))}if(!r.buildTxn)throw new Error("Service unavailable");const A=r.buildTxn,P=A.modifyMultisigAccountBuilder().minApprovalDelta(i).minRemovalDelta(c).modifications(l).build(),I=A.aggregateBondedBuilder().innerTransactions([P.toAggregateV1(f.publicAccount)]).build();if(!w.currentNetworkProfile)throw new Error("Service unavailable");const M=f.preV2Sign(I,w.currentNetworkProfile.generationHash),y=E.lockFundTx(M),v=f.preV2Sign(y,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(v,M),d}static getAggregateBondedTransactions(n){return T.getAggregateBondedTransactions(n)}static async onPartial(n){const i=await S.getAggregateBondedTransactions(n);if(i.length){for(const c of i)for(let o=0;o<c.innerTransactions.length;o++)if(c.innerTransactions[o].signer.publicKey===n.publicKey)return!0}return!1}static getMultisigAccountGraphInfo(n){return T.getMultisigAccGraphInfo(t.Address.createFromRawAddress(n))}static checkIsMultiSig(n){const i=b.currentLoggedInWallet;if(!i)throw new Error("Service unavailable");const c=i.accounts.find(o=>o.address===n)||i.others.find(o=>o.address===n);if(!c)throw new Error("Account not found");return c.getDirectParentMultisig().length>0}static checkHasMultiSig(n){const i=b.currentLoggedInWallet;if(!i)throw new Error("Service unavailable");const c=i.accounts.find(o=>o.address===n)||i.others.find(o=>o.address===n);if(!c)throw new Error("Account not found");return c.multisigInfo.filter(o=>o.level==-1).length>0}static getCosignerInWallet(n){if(!b.currentLoggedInWallet)throw new Error("Service unavailable");if(!w.currentNetworkProfileConfig)throw new Error("Service unavailable");const i=b.currentLoggedInWallet.accounts.map(e=>({publicKey:e.publicKey,isMultisig:!!e.getDirectParentMultisig().length,multisigInfo:e.multisigInfo})),c=b.currentLoggedInWallet.others.filter(e=>e.type==="MULTISIG").map(e=>({publicKey:e.publicKey,isMultisig:!0,multisigInfo:e.multisigInfo})),o=i.concat(c),a=o.find(e=>e.publicKey==n);if(!a)throw new Error("Account not found");const u=[];o.forEach(e=>{!e.isMultisig&&e.multisigInfo.filter(f=>f.level==-1).length>0&&u.push(e)});const d=w.currentNetworkProfileConfig.maxMultisigDepth;if(!d)throw new Error("Service unavailable");const l=[];for(let e=1;e<=d;e++)a.multisigInfo.filter(s=>s.level==e).forEach(s=>{u.forEach(A=>{A.publicKey==s.publicKey&&l.push(s.publicKey)})});let g=!1;return l.length>0&&(g=!0),{hasCosigner:g,cosignerList:l}}static async modifyMultisigAccount(n,i,c,o,a,u,d){const l=b.currentLoggedInWallet;if(!l)throw new Error("Service unavailable");if(!r.chainAPI)throw new Error("Service unavailable");if(!T.verifyWalletPassword(l.name,w.chainNetworkName,d))return!1;const g=[],e=[];for(const[h,m]of i.entries()){if(m.length==64)e[h]=t.PublicAccount.createFromPublicKey(m,r.networkType);else if(m.length==40||m.length==46){const x=t.Address.createFromRawAddress(m);try{const F=await r.chainAPI.accountAPI.getAccountInfo(x);e[h]=t.PublicAccount.createFromPublicKey(F.publicKey,r.networkType)}catch(F){console.log(F)}}g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,e[h]))}c.forEach((h,m)=>{e[i.length+m]=t.PublicAccount.createFromPublicKey(h,r.networkType),g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,e[i.length+m]))});const f=u.multisigInfo.find(h=>h.level===0);if(!f)throw new Error("Account not found");const s=o-f.minApproval,A=a-f.minRemoval;if(!r.buildTxn)throw new Error("Service unavailable");const P=r.buildTxn,I=P.modifyMultisigAccountBuilder().minApprovalDelta(s).minRemovalDelta(A).modifications(g).build(),M=t.PublicAccount.createFromPublicKey(u.publicKey,r.networkType),y=P.aggregateBondedBuilder().innerTransactions([I.toAggregateV1(M)]).build(),v=l.accounts.find(h=>h.publicKey==n);if(!v)throw new Error("Account not found");if(!w.currentNetworkProfile)throw new Error("Service unavailable");const p=T.decryptPrivateKey(new t.Password(d),v.encrypted,v.iv),k=t.Account.createFromPrivateKey(p,r.networkType,1),K=k.preV2Sign(y,w.currentNetworkProfile.generationHash),C=E.lockFundTx(K),N=k.preV2Sign(C,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(N,K),!0}};S.getAggregateFee=(n,i,c,o,a)=>{const u=b.currentLoggedInWallet;if(!r.chainAPI||!u)throw new Error("Service unavailable");const d=u.accounts.find(y=>y.publicKey==n)||u.others.find(y=>y.publicKey==n);if(!d)throw new Error("Account not found");const l=[];for(const y of i)l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,t.PublicAccount.createFromPublicKey("0".repeat(64),r.networkType)));const g=[];if(a&&a.forEach((y,v)=>{g[i.length+v]=t.PublicAccount.createFromPublicKey(y,r.networkType),l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,g[i.length+v]))}),!r.buildTxn)throw new Error("Service unavailable");const e=r.buildTxn,f=t.PublicAccount.createFromPublicKey(n,r.networkType),s=d.multisigInfo.find(y=>y.level===0);if(!s)throw new Error("Account not found");const A=c-s.minApproval,P=o-s.minRemoval,I=e.modifyMultisigAccountBuilder().minApprovalDelta(A).minRemovalDelta(P).modifications(l).build();return e.aggregateBondedBuilder().innerTransactions([I.toAggregateV1(f)]).build().maxFee.compact()/Math.pow(10,r.nativeToken.divisibility)};let B=S;export{B as M};
