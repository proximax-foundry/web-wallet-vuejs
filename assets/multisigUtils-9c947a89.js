import{W as b,w as m,n as y,z as t,B as n,S as E}from"./index-3c3de18f.js";const N=class C{static verifyContactPublicKey(i){const r="0000000000000000000000000000000000000000000000000000000000000000";return new Promise(c=>{b.getAccInfo(i).then(a=>{a.publicKey==r?(console.warn("The receiver's public key is not valid for sending encrypted messages"),c({status:!1,publicKey:a.publicKey})):c({status:!0,publicKey:a.publicKey})},a=>{console.warn("Err: "+a),c({status:!1,publicKey:""})})})}static async convertAccount(i,r,c,o,a){const g=m.currentLoggedInWallet;if(!g)throw new Error("Service unavailable");const l=b.verifyWalletPassword(g.name,y.chainNetworkName,a);if(!l)return l;const u=[],e=g.accounts.find(p=>p.name===o);if(!e)throw new Error("Account not found");const d=b.decryptPrivateKey(new t.Password(a),e.encrypted,e.iv),s=t.Account.createFromPrivateKey(d,n.networkType,1);if(!n.chainAPI)throw new Error("Service unavailable");let w=null;for(const p of i){if(p.length==64)w=t.PublicAccount.createFromPublicKey(p,n.networkType);else if(p.length==40||p.length==46){const k=t.Address.createFromRawAddress(p);try{const I=await n.chainAPI.accountAPI.getAccountInfo(k);w=t.PublicAccount.createFromPublicKey(I.publicKey,n.networkType)}catch(I){console.log(I)}}w&&u.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,w))}if(!n.buildTxn)throw new Error("Service unavailable");const T=n.buildTxn,P=T.modifyMultisigAccountBuilder().minApprovalDelta(r).minRemovalDelta(c).modifications(u).build(),K=await n.chainAPI.nodeAPI.getNodeTime(),f=T.aggregateBondedBuilder(new t.UInt64(K.sendTimeStamp)).innerTransactions([P.toAggregateV1(s.publicAccount)]).build();if(!y.currentNetworkProfile)throw new Error("Service unavailable");const v=s.preV2Sign(f,y.currentNetworkProfile.generationHash),B=E.lockFundTx(v),M=s.preV2Sign(B,y.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(M,v),l}static getAggregateBondedTransactions(i){return b.getAggregateBondedTransactions(i)}static async onPartial(i){const r=await C.getAggregateBondedTransactions(i);if(r.length){for(const c of r)for(let o=0;o<c.innerTransactions.length;o++)if(c.innerTransactions[o].signer.publicKey===i.publicKey)return!0}return!1}static getMultisigAccountGraphInfo(i){return b.getMultisigAccGraphInfo(t.Address.createFromRawAddress(i))}static checkIsMultiSig(i){const r=m.currentLoggedInWallet;if(!r)throw new Error("Service unavailable");const c=r.accounts.find(o=>o.address===i)||r.others.find(o=>o.address===i);if(!c)throw new Error("Account not found");return c.getDirectParentMultisig().length>0}static checkHasMultiSig(i){const r=m.currentLoggedInWallet;if(!r)throw new Error("Service unavailable");const c=r.accounts.find(o=>o.address===i)||r.others.find(o=>o.address===i);if(!c)throw new Error("Account not found");return c.multisigInfo.filter(o=>o.level==-1).length>0}static getCosignerInWallet(i){if(!m.currentLoggedInWallet)throw new Error("Service unavailable");if(!y.currentNetworkProfileConfig)throw new Error("Service unavailable");const r=m.currentLoggedInWallet.accounts.map(e=>({publicKey:e.publicKey,isMultisig:!!e.getDirectParentMultisig().length,multisigInfo:e.multisigInfo})),c=m.currentLoggedInWallet.others.filter(e=>e.type==="MULTISIG").map(e=>({publicKey:e.publicKey,isMultisig:!0,multisigInfo:e.multisigInfo})),o=r.concat(c),a=o.find(e=>e.publicKey==i);if(!a)throw new Error("Account not found");const g=[];o.forEach(e=>{!e.isMultisig&&e.multisigInfo.filter(d=>d.level==-1).length>0&&g.push(e)});const l=y.currentNetworkProfileConfig.maxMultisigDepth;if(!l)throw new Error("Service unavailable");const u=[];for(let e=1;e<=l;e++)a.multisigInfo.filter(s=>s.level==e).forEach(s=>{g.forEach(w=>{w.publicKey==s.publicKey&&u.push(s.publicKey)})});return{hasCosigner:u.length>0,cosignerList:u}}static async modifyMultisigAccount(i,r,c,o,a,g,l){const u=m.currentLoggedInWallet;if(!u)throw new Error("Service unavailable");if(!n.chainAPI)throw new Error("Service unavailable");if(!b.verifyWalletPassword(u.name,y.chainNetworkName,l))return!1;const e=[],d=[];for(const[h,A]of r.entries()){if(A.length==64)d[h]=t.PublicAccount.createFromPublicKey(A,n.networkType);else if(A.length==40||A.length==46){const D=t.Address.createFromRawAddress(A);try{const F=await n.chainAPI.accountAPI.getAccountInfo(D);d[h]=t.PublicAccount.createFromPublicKey(F.publicKey,n.networkType)}catch(F){console.log(F)}}e.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,d[h]))}c.forEach((h,A)=>{d[r.length+A]=t.PublicAccount.createFromPublicKey(h,n.networkType),e.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,d[r.length+A]))});const s=g.multisigInfo.find(h=>h.level===0);if(!s)throw new Error("Account not found");const w=o-s.minApproval,T=a-s.minRemoval;if(!n.buildTxn)throw new Error("Service unavailable");const P=n.buildTxn,K=P.modifyMultisigAccountBuilder().minApprovalDelta(w).minRemovalDelta(T).modifications(e).build(),f=t.PublicAccount.createFromPublicKey(g.publicKey,n.networkType),v=await n.chainAPI.nodeAPI.getNodeTime(),B=P.aggregateBondedBuilder(new t.UInt64(v.sendTimeStamp)).innerTransactions([K.toAggregateV1(f)]).build(),M=u.accounts.find(h=>h.publicKey==i);if(!M)throw new Error("Account not found");if(!y.currentNetworkProfile)throw new Error("Service unavailable");const p=b.decryptPrivateKey(new t.Password(l),M.encrypted,M.iv),k=t.Account.createFromPrivateKey(p,n.networkType,1),I=k.preV2Sign(B,y.currentNetworkProfile.generationHash),x=E.lockFundTx(I),L=k.preV2Sign(x,y.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(L,I),!0}};N.getAggregateFee=(S,i,r,c,o)=>{const a=m.currentLoggedInWallet;if(!n.chainAPI||!a)throw new Error("Service unavailable");const g=a.accounts.find(f=>f.publicKey==S)||a.others.find(f=>f.publicKey==S);if(!g)throw new Error("Account not found");const l=[];for(const f of i)l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,t.PublicAccount.createFromPublicKey("0".repeat(64),n.networkType)));const u=[];if(o&&o.forEach((f,v)=>{u[i.length+v]=t.PublicAccount.createFromPublicKey(f,n.networkType),l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,u[i.length+v]))}),!n.buildTxn)throw new Error("Service unavailable");const e=n.buildTxn,d=t.PublicAccount.createFromPublicKey(S,n.networkType),s=g.multisigInfo.find(f=>f.level===0);if(!s)throw new Error("Account not found");const w=r-s.minApproval,T=c-s.minRemoval,P=e.modifyMultisigAccountBuilder().minApprovalDelta(w).minRemovalDelta(T).modifications(l).build();return e.aggregateBondedBuilder().innerTransactions([P.toAggregateV1(d)]).build().maxFee.compact()/Math.pow(10,n.nativeToken.divisibility)};let R=N;export{R as M};
