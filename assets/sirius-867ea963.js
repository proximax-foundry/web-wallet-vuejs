import{B as t,E as n,aw as I,av as P,n as k,ax as w}from"./index-4bc58919.js";let b=[{namespace:"prx.xpx",name:"XPX"},{namespace:"prx.metx",name:"METX"},{namespace:"xarcade.xar",name:"XAR"}];class N{static createAccount(u){return t.Account.createFromPrivateKey(u,n.networkType,1)}static async scanAsset(u){let s=t.PublicAccount.createFromPublicKey(u,n.networkType);try{let m=await n.chainAPI.accountAPI.getAccountInfo(s.address),r=m.mosaics.map(h=>h.id),x=await n.chainAPI.assetAPI.getMosaics(r),d=await n.chainAPI.assetAPI.getMosaicsNames(r);return m.mosaics.map(h=>{let g=h.id.toHex(),o=x.find(l=>l.mosaicId.toHex()===g).divisibility,e=d.find(l=>l.mosaicId.toHex()===g).names,i=e.length?e[0].name:"",a=b.find(l=>l.namespace===i),c={id:g,amount:o?h.amount.compact()/Math.pow(10,o):h.amount.compact(),divisibility:o,namespaceName:i};return c.label=a?a.name:c.namespaceName?c.namespaceName:c.id.toUpperCase(),c})}catch{return[]}}static createDistributeAggregateTransactions(u,s,m,r){let x=t.PublicAccount.createFromPublicKey(u,n.networkType),d=[],f=Math.ceil(s.length/m),h=[],g=Math.pow(10,r.divisibility),o=r.namespaceName?new t.NamespaceId(r.namespaceName):new t.MosaicId(r.id);for(let e=0;e<s.length;++e){let i=I(P(s[e].amount),g),a=Number(i.toString()),c;s[e].publicKeyOrAddress.length===64?c=t.PublicAccount.createFromPublicKey(s[e].publicKeyOrAddress,n.networkType).address:c=t.Address.createFromRawAddress(s[e].publicKeyOrAddress);let l=new t.Mosaic(o,t.UInt64.fromUint(a)),p;s[e].message?p=t.PlainMessage.create(s[e].message):p=t.EmptyMessage;let A=n.buildTxn.transfer(c,p,[l]);h.push(A)}for(let e=0;e<f;++e){let i=e*m,a=(e+1)*m,c=h.slice(i,a),l=[];for(let A=0;A<c.length;++A)l.push(c[A].toAggregateV1(x));let p=n.buildTxn.aggregateBonded(l);d.push(p)}return d}static getLockFundTransactionFee(){const u=k.currentNetworkProfileConfig.lockedFundsPerAggregate??0;let s=new t.TransactionHash("0".repeat(64),t.TransactionType.AGGREGATE_BONDED_V1);return n.buildTxn.hashLock(new t.Mosaic(new t.NamespaceId("prx.xpx"),t.UInt64.fromUint(u)),t.UInt64.fromUint(w.getABTMaxSafeDuration()),s).maxFee.compact()}static async signAllAbtAndAnnounce(u,s){const m=k.currentNetworkProfileConfig.lockedFundsPerAggregate;let r=[],x=[],d=[],f=[];for(let o=0;o<u.length;++o){let e=s.preV2Sign(u[o],k.currentNetworkProfile.generationHash);r.push(e);let i=n.buildTxn.hashLock(new t.Mosaic(new t.NamespaceId(n.nativeToken.fullNamespace.trim()),t.UInt64.fromUint(m)),t.UInt64.fromUint(w.getABTMaxSafeDuration()),e),a=s.preV2Sign(i,k.currentNetworkProfile.generationHash);x.push(a),d.push({txnHash:e.hash,block:null}),d.push({txnHash:a.hash,block:null}),f.push({txnHash:e.hash,hashLockHash:a.hash})}let h=!1;for(let o=0;o<x.length;++o)await n.chainAPI.transactionAPI.announce(x[o]);console.log("All LockHash Txn announced, pending ABT announcement...");let g=[];for(;!h;){await new Promise(a=>setTimeout(a,15e3)),console.log("Checking LockHash Txn confirmation...");let e=await n.chainAPI.chainAPI.getBlockchainHeight(),i=r.filter(a=>!g.includes(a.hash));for(let a=0;a<i.length;++a){let c=f.find(p=>p.txnHash===i[a].hash).hashLockHash,l=await n.chainAPI.transactionAPI.getTransactionStatus(c);if(l.group===t.TransactionGroupType.CONFIRMED){let p=l.height.compact(),A=d.find(T=>T.txnHash===c);A.block=p,e>=A.block+1&&(await n.chainAPI.transactionAPI.announceAggregateBonded(i[a]),g.push(i[a].hash))}}g.length===r.length&&(h=!0)}return g}}export{N as S};
