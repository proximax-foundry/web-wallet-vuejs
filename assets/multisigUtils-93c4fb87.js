import{W as m,w as b,n as w,A as t,G as o,X as E}from"./index-50355987.js";const B=class C{static verifyContactPublicKey(n){const r="0000000000000000000000000000000000000000000000000000000000000000";return new Promise(c=>{m.getAccInfo(n).then(a=>{a.publicKey==r?(console.warn("The receiver's public key is not valid for sending encrypted messages"),c({status:!1,publicKey:a.publicKey})):c({status:!0,publicKey:a.publicKey})},a=>{console.warn("Err: "+a),c({status:!1,publicKey:""})})})}static async convertAccount(n,r,c,i,a){const y=b.currentLoggedInWallet;if(!y)throw new Error("Service unavailable");const l=m.verifyWalletPassword(y.name,w.chainNetworkName,a);if(!l)return l;const u=[],g=y.accounts.find(p=>p.name===i);if(!g)throw new Error("Account not found");const e=m.decryptPrivateKey(new t.Password(a),g.encrypted,g.iv),s=t.Account.createFromPrivateKey(e,o.networkType,1);if(!o.chainAPI)throw new Error("Service unavailable");let d=null;for(const p of n){if(p.length==64)d=t.PublicAccount.createFromPublicKey(p,o.networkType);else if(p.length==40||p.length==46){const k=t.Address.createFromRawAddress(p);try{const M=await o.chainAPI.accountAPI.getAccountInfo(k);d=t.PublicAccount.createFromPublicKey(M.publicKey,o.networkType)}catch(M){console.log(M)}}d&&u.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,d))}if(!o.buildTxn)throw new Error("Service unavailable");const A=o.buildTxn,T=A.modifyMultisigAccountBuilder().minApprovalDelta(r).minRemovalDelta(c).modifications(u).build(),I=A.aggregateBondedBuilder().innerTransactions([T.toAggregateV1(s.publicAccount)]).build();if(!w.currentNetworkProfile)throw new Error("Service unavailable");const f=s.preV2Sign(I,w.currentNetworkProfile.generationHash),P=E.lockFundTx(f),K=s.preV2Sign(P,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(K,f),l}static getAggregateBondedTransactions(n){return m.getAggregateBondedTransactions(n)}static async onPartial(n){const r=await C.getAggregateBondedTransactions(n);if(r.length){for(const c of r)for(let i=0;i<c.innerTransactions.length;i++)if(c.innerTransactions[i].signer.publicKey===n.publicKey)return!0}return!1}static getMultisigAccountGraphInfo(n){return m.getMultisigAccGraphInfo(t.Address.createFromRawAddress(n))}static checkIsMultiSig(n){const r=b.currentLoggedInWallet;if(!r)throw new Error("Service unavailable");const c=r.accounts.find(i=>i.address===n)||r.others.find(i=>i.address===n);if(!c)throw new Error("Account not found");return c.getDirectParentMultisig().length>0}static checkHasMultiSig(n){const r=b.currentLoggedInWallet;if(!r)throw new Error("Service unavailable");const c=r.accounts.find(i=>i.address===n)||r.others.find(i=>i.address===n);if(!c)throw new Error("Account not found");return c.multisigInfo.filter(i=>i.level==-1).length>0}static getCosignerInWallet(n){if(!b.currentLoggedInWallet)throw new Error("Service unavailable");if(!w.currentNetworkProfileConfig)throw new Error("Service unavailable");const r=b.currentLoggedInWallet.accounts.map(e=>({publicKey:e.publicKey,isMultisig:!!e.getDirectParentMultisig().length,multisigInfo:e.multisigInfo})),c=b.currentLoggedInWallet.others.filter(e=>e.type==="MULTISIG").map(e=>({publicKey:e.publicKey,isMultisig:!0,multisigInfo:e.multisigInfo})),i=r.concat(c),a=i.find(e=>e.publicKey==n);if(!a)throw new Error("Account not found");const y=[];i.forEach(e=>{!e.isMultisig&&e.multisigInfo.filter(s=>s.level==-1).length>0&&y.push(e)});const l=w.currentNetworkProfileConfig.maxMultisigDepth;if(!l)throw new Error("Service unavailable");const u=[];for(let e=1;e<=l;e++)a.multisigInfo.filter(d=>d.level==e).forEach(d=>{y.forEach(A=>{A.publicKey==d.publicKey&&u.push(d.publicKey)})});let g=!1;return u.length>0&&(g=!0),{hasCosigner:g,cosignerList:u}}static async modifyMultisigAccount(n,r,c,i,a,y,l){const u=b.currentLoggedInWallet;if(!u)throw new Error("Service unavailable");if(!o.chainAPI)throw new Error("Service unavailable");if(!m.verifyWalletPassword(u.name,w.chainNetworkName,l))return!1;const g=[],e=[];for(const[h,v]of r.entries()){if(v.length==64)e[h]=t.PublicAccount.createFromPublicKey(v,o.networkType);else if(v.length==40||v.length==46){const L=t.Address.createFromRawAddress(v);try{const F=await o.chainAPI.accountAPI.getAccountInfo(L);e[h]=t.PublicAccount.createFromPublicKey(F.publicKey,o.networkType)}catch(F){console.log(F)}}g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,e[h]))}c.forEach((h,v)=>{e[r.length+v]=t.PublicAccount.createFromPublicKey(h,o.networkType),g.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,e[r.length+v]))});const s=y.multisigInfo.find(h=>h.level===0);if(!s)throw new Error("Account not found");const d=i-s.minApproval,A=a-s.minRemoval;if(!o.buildTxn)throw new Error("Service unavailable");const T=o.buildTxn,I=T.modifyMultisigAccountBuilder().minApprovalDelta(d).minRemovalDelta(A).modifications(g).build(),f=t.PublicAccount.createFromPublicKey(y.publicKey,o.networkType),P=T.aggregateBondedBuilder().innerTransactions([I.toAggregateV1(f)]).build(),K=u.accounts.find(h=>h.publicKey==n);if(!K)throw new Error("Account not found");if(!w.currentNetworkProfile)throw new Error("Service unavailable");const p=m.decryptPrivateKey(new t.Password(l),K.encrypted,K.iv),k=t.Account.createFromPrivateKey(p,o.networkType,1),M=k.preV2Sign(P,w.currentNetworkProfile.generationHash),N=E.lockFundTx(M),x=k.preV2Sign(N,w.currentNetworkProfile.generationHash);return E.announceLF_AND_addAutoAnnounceABT(x,M),!0}};B.getAggregateFee=(S,n,r,c,i)=>{const a=b.currentLoggedInWallet;if(!o.chainAPI||!a)throw new Error("Service unavailable");const y=a.accounts.find(f=>f.publicKey==S)||a.others.find(f=>f.publicKey==S);if(!y)throw new Error("Account not found");const l=[];for(const f of n)l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Add,t.PublicAccount.createFromPublicKey("0".repeat(64),o.networkType)));const u=[];if(i&&i.forEach((f,P)=>{u[n.length+P]=t.PublicAccount.createFromPublicKey(f,o.networkType),l.push(new t.MultisigCosignatoryModification(t.MultisigCosignatoryModificationType.Remove,u[n.length+P]))}),!o.buildTxn)throw new Error("Service unavailable");const g=o.buildTxn,e=t.PublicAccount.createFromPublicKey(S,o.networkType),s=y.multisigInfo.find(f=>f.level===0);if(!s)throw new Error("Account not found");const d=r-s.minApproval,A=c-s.minRemoval,T=g.modifyMultisigAccountBuilder().minApprovalDelta(d).minRemovalDelta(A).modifications(l).build();return g.aggregateBondedBuilder().innerTransactions([T.toAggregateV1(e)]).build().maxFee.compact()/Math.pow(10,o.nativeToken.divisibility)};let W=B;export{W as M};
