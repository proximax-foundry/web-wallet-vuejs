const C=crypto,N=t=>t instanceof CryptoKey,y=new TextEncoder,b=new TextDecoder;function D(...t){const e=t.reduce((o,{length:a})=>o+a,0),r=new Uint8Array(e);let n=0;return t.forEach(o=>{r.set(o,n),n+=o.length}),r}const Z=t=>{let e=t;typeof e=="string"&&(e=y.encode(e));const r=32768,n=[];for(let o=0;o<e.length;o+=r)n.push(String.fromCharCode.apply(null,e.subarray(o,o+r)));return btoa(n.join(""))},W=t=>Z(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),Q=t=>{const e=atob(t),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r},J=t=>{let e=t;e instanceof Uint8Array&&(e=b.decode(e)),e=e.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return Q(e)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class g extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(e){var r;super(e),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(r=Error.captureStackTrace)===null||r===void 0||r.call(Error,this,this.constructor)}}class u extends g{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(e,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=r,this.reason=n}}class $ extends g{static get code(){return"ERR_JWT_EXPIRED"}constructor(e,r="unspecified",n="unspecified"){super(e),this.code="ERR_JWT_EXPIRED",this.claim=r,this.reason=n}}class Y extends g{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class L extends g{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class s extends g{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class f extends g{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class ee extends g{constructor(){super(...arguments),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED",this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function m(t,e="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${e} must be ${t}`)}function H(t,e){return t.name===e}function P(t){return parseInt(t.name.slice(4),10)}function te(t){switch(t){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function re(t,e){if(e.length&&!e.some(r=>t.usages.includes(r))){let r="CryptoKey does not support this operation, its usages must include ";if(e.length>2){const n=e.pop();r+=`one of ${e.join(", ")}, or ${n}.`}else e.length===2?r+=`one of ${e[0]} or ${e[1]}.`:r+=`${e[0]}.`;throw new TypeError(r)}}function ne(t,e,...r){switch(e){case"HS256":case"HS384":case"HS512":{if(!H(t.algorithm,"HMAC"))throw m("HMAC");const n=parseInt(e.slice(2),10);if(P(t.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!H(t.algorithm,"RSASSA-PKCS1-v1_5"))throw m("RSASSA-PKCS1-v1_5");const n=parseInt(e.slice(2),10);if(P(t.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!H(t.algorithm,"RSA-PSS"))throw m("RSA-PSS");const n=parseInt(e.slice(2),10);if(P(t.algorithm.hash)!==n)throw m(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":{if(t.algorithm.name!=="Ed25519"&&t.algorithm.name!=="Ed448")throw m("Ed25519 or Ed448");break}case"ES256":case"ES384":case"ES512":{if(!H(t.algorithm,"ECDSA"))throw m("ECDSA");const n=te(e);if(t.algorithm.namedCurve!==n)throw m(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}re(t,r)}function K(t,e,...r){if(r.length>2){const n=r.pop();t+=`one of type ${r.join(", ")}, or ${n}.`}else r.length===2?t+=`one of type ${r[0]} or ${r[1]}.`:t+=`of type ${r[0]}.`;return e==null?t+=` Received ${e}`:typeof e=="function"&&e.name?t+=` Received function ${e.name}`:typeof e=="object"&&e!=null&&e.constructor&&e.constructor.name&&(t+=` Received an instance of ${e.constructor.name}`),t}const x=(t,...e)=>K("Key must be ",t,...e);function M(t,e,...r){return K(`Key for the ${t} algorithm must be `,e,...r)}const F=t=>N(t),p=["CryptoKey"],V=(...t)=>{const e=t.filter(Boolean);if(e.length===0||e.length===1)return!0;let r;for(const n of e){const o=Object.keys(n);if(!r||r.size===0){r=new Set(o);continue}for(const a of o){if(r.has(a))return!1;r.add(a)}}return!0};function oe(t){return typeof t=="object"&&t!==null}function A(t){if(!oe(t)||Object.prototype.toString.call(t)!=="[object Object]")return!1;if(Object.getPrototypeOf(t)===null)return!0;let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}const k=(t,e)=>{if(t.startsWith("RS")||t.startsWith("PS")){const{modulusLength:r}=e.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${t} requires key modulusLength to be 2048 bits or larger`)}},ae=(t,e)=>{if(!(e instanceof Uint8Array)){if(!F(e))throw new TypeError(M(t,e,...p,"Uint8Array"));if(e.type!=="secret")throw new TypeError(`${p.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}},ie=(t,e,r)=>{if(!F(e))throw new TypeError(M(t,e,...p));if(e.type==="secret")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if(r==="sign"&&e.type==="public")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if(r==="decrypt"&&e.type==="public")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(e.algorithm&&r==="verify"&&e.type==="private")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(e.algorithm&&r==="encrypt"&&e.type==="private")throw new TypeError(`${p.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)},G=(t,e,r)=>{t.startsWith("HS")||t==="dir"||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?ae(t,e):ie(t,e,r)};function j(t,e,r,n,o){if(o.crit!==void 0&&n.crit===void 0)throw new t('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(i=>typeof i!="string"||i.length===0))throw new t('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let a;r!==void 0?a=new Map([...Object.entries(r),...e.entries()]):a=e;for(const i of n.crit){if(!a.has(i))throw new L(`Extension Header Parameter "${i}" is not recognized`);if(o[i]===void 0)throw new t(`Extension Header Parameter "${i}" is missing`);if(a.get(i)&&n[i]===void 0)throw new t(`Extension Header Parameter "${i}" MUST be integrity protected`)}return new Set(n.crit)}const se=(t,e)=>{if(e!==void 0&&(!Array.isArray(e)||e.some(r=>typeof r!="string")))throw new TypeError(`"${t}" option must be an array of strings`);if(e)return new Set(e)};function z(t,e){const r=`SHA-${t.slice(-3)}`;switch(t){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:t.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:e.namedCurve};case"EdDSA":return{name:e.name};default:throw new L(`alg ${t} is not supported either by JOSE or your javascript runtime`)}}function B(t,e,r){if(N(e))return ne(e,t,r),e;if(e instanceof Uint8Array){if(!t.startsWith("HS"))throw new TypeError(x(e,...p));return C.subtle.importKey("raw",e,{hash:`SHA-${t.slice(-3)}`,name:"HMAC"},!1,[r])}throw new TypeError(x(e,...p,"Uint8Array"))}const ce=async(t,e,r,n)=>{const o=await B(t,e,"verify");k(t,o);const a=z(t,o.algorithm);try{return await C.subtle.verify(a,o,r,n)}catch{return!1}};async function de(t,e,r){var n;if(!A(t))throw new s("Flattened JWS must be an object");if(t.protected===void 0&&t.header===void 0)throw new s('Flattened JWS must have either of the "protected" or "header" members');if(t.protected!==void 0&&typeof t.protected!="string")throw new s("JWS Protected Header incorrect type");if(t.payload===void 0)throw new s("JWS Payload missing");if(typeof t.signature!="string")throw new s("JWS Signature missing or incorrect type");if(t.header!==void 0&&!A(t.header))throw new s("JWS Unprotected Header incorrect type");let o={};if(t.protected)try{const O=J(t.protected);o=JSON.parse(b.decode(O))}catch{throw new s("JWS Protected Header is invalid")}if(!V(o,t.header))throw new s("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...o,...t.header},i=j(s,new Map([["b64",!0]]),r==null?void 0:r.crit,o,a);let d=!0;if(i.has("b64")&&(d=o.b64,typeof d!="boolean"))throw new s('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:c}=a;if(typeof c!="string"||!c)throw new s('JWS "alg" (Algorithm) Header Parameter missing or invalid');const h=r&&se("algorithms",r.algorithms);if(h&&!h.has(c))throw new Y('"alg" (Algorithm) Header Parameter not allowed');if(d){if(typeof t.payload!="string")throw new s("JWS Payload must be a string")}else if(typeof t.payload!="string"&&!(t.payload instanceof Uint8Array))throw new s("JWS Payload must be a string or an Uint8Array instance");let l=!1;typeof e=="function"&&(e=await e(o,t),l=!0),G(c,e,"verify");const w=D(y.encode((n=t.protected)!==null&&n!==void 0?n:""),y.encode("."),typeof t.payload=="string"?y.encode(t.payload):t.payload),E=J(t.signature);if(!await ce(c,e,E,w))throw new ee;let _;d?_=J(t.payload):typeof t.payload=="string"?_=y.encode(t.payload):_=t.payload;const T={payload:_};return t.protected!==void 0&&(T.protectedHeader=o),t.header!==void 0&&(T.unprotectedHeader=t.header),l?{...T,key:e}:T}async function le(t,e,r){if(t instanceof Uint8Array&&(t=b.decode(t)),typeof t!="string")throw new s("Compact JWS must be a string or Uint8Array");const{0:n,1:o,2:a,length:i}=t.split(".");if(i!==3)throw new s("Invalid Compact JWS");const d=await de({payload:o,protected:n,signature:a},e,r),c={payload:d.payload,protectedHeader:d.protectedHeader};return typeof e=="function"?{...c,key:d.key}:c}const v=t=>Math.floor(t.getTime()/1e3),q=60,X=q*60,I=X*24,he=I*7,ue=I*365.25,fe=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,R=t=>{const e=fe.exec(t);if(!e)throw new TypeError("Invalid time period format");const r=parseFloat(e[1]);switch(e[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(r*q);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(r*X);case"day":case"days":case"d":return Math.round(r*I);case"week":case"weeks":case"w":return Math.round(r*he);default:return Math.round(r*ue)}},U=t=>t.toLowerCase().replace(/^application\//,""),pe=(t,e)=>typeof t=="string"?e.includes(t):Array.isArray(t)?e.some(Set.prototype.has.bind(new Set(t))):!1,ye=(t,e,r={})=>{const{typ:n}=r;if(n&&(typeof t.typ!="string"||U(t.typ)!==U(n)))throw new u('unexpected "typ" JWT header value',"typ","check_failed");let o;try{o=JSON.parse(b.decode(e))}catch{}if(!A(o))throw new f("JWT Claims Set must be a top-level JSON object");const{requiredClaims:a=[],issuer:i,subject:d,audience:c,maxTokenAge:h}=r;h!==void 0&&a.push("iat"),c!==void 0&&a.push("aud"),d!==void 0&&a.push("sub"),i!==void 0&&a.push("iss");for(const S of new Set(a.reverse()))if(!(S in o))throw new u(`missing required "${S}" claim`,S,"missing");if(i&&!(Array.isArray(i)?i:[i]).includes(o.iss))throw new u('unexpected "iss" claim value',"iss","check_failed");if(d&&o.sub!==d)throw new u('unexpected "sub" claim value',"sub","check_failed");if(c&&!pe(o.aud,typeof c=="string"?[c]:c))throw new u('unexpected "aud" claim value',"aud","check_failed");let l;switch(typeof r.clockTolerance){case"string":l=R(r.clockTolerance);break;case"number":l=r.clockTolerance;break;case"undefined":l=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:w}=r,E=v(w||new Date);if((o.iat!==void 0||h)&&typeof o.iat!="number")throw new u('"iat" claim must be a number',"iat","invalid");if(o.nbf!==void 0){if(typeof o.nbf!="number")throw new u('"nbf" claim must be a number',"nbf","invalid");if(o.nbf>E+l)throw new u('"nbf" claim timestamp check failed',"nbf","check_failed")}if(o.exp!==void 0){if(typeof o.exp!="number")throw new u('"exp" claim must be a number',"exp","invalid");if(o.exp<=E-l)throw new $('"exp" claim timestamp check failed',"exp","check_failed")}if(h){const S=E-o.iat,_=typeof h=="number"?h:R(h);if(S-l>_)throw new $('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(S<0-l)throw new u('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return o};async function _e(t,e,r){var n;const o=await le(t,e,r);if(!((n=o.protectedHeader.crit)===null||n===void 0)&&n.includes("b64")&&o.protectedHeader.b64===!1)throw new f("JWTs MUST NOT use unencoded payload");const i={payload:ye(o.protectedHeader,o.payload,r),protectedHeader:o.protectedHeader};return typeof e=="function"?{...i,key:o.key}:i}const me=async(t,e,r)=>{const n=await B(t,e,"sign");k(t,n);const o=await C.subtle.sign(z(t,n.algorithm),n,r);return new Uint8Array(o)};class we{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");return this._protectedHeader=e,this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");return this._unprotectedHeader=e,this}async sign(e,r){if(!this._protectedHeader&&!this._unprotectedHeader)throw new s("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!V(this._protectedHeader,this._unprotectedHeader))throw new s("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n={...this._protectedHeader,...this._unprotectedHeader},o=j(s,new Map([["b64",!0]]),r==null?void 0:r.crit,this._protectedHeader,n);let a=!0;if(o.has("b64")&&(a=this._protectedHeader.b64,typeof a!="boolean"))throw new s('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=n;if(typeof i!="string"||!i)throw new s('JWS "alg" (Algorithm) Header Parameter missing or invalid');G(i,e,"sign");let d=this._payload;a&&(d=y.encode(W(d)));let c;this._protectedHeader?c=y.encode(W(JSON.stringify(this._protectedHeader))):c=y.encode("");const h=D(c,y.encode("."),d),l=await me(i,e,h),w={signature:W(l),payload:""};return a&&(w.payload=b.decode(d)),this._unprotectedHeader&&(w.header=this._unprotectedHeader),this._protectedHeader&&(w.protected=b.decode(c)),w}}class Se{constructor(e){this._flattened=new we(e)}setProtectedHeader(e){return this._flattened.setProtectedHeader(e),this}async sign(e,r){const n=await this._flattened.sign(e,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`}}class be{constructor(e){if(!A(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){return this._payload={...this._payload,iss:e},this}setSubject(e){return this._payload={...this._payload,sub:e},this}setAudience(e){return this._payload={...this._payload,aud:e},this}setJti(e){return this._payload={...this._payload,jti:e},this}setNotBefore(e){return typeof e=="number"?this._payload={...this._payload,nbf:e}:this._payload={...this._payload,nbf:v(new Date)+R(e)},this}setExpirationTime(e){return typeof e=="number"?this._payload={...this._payload,exp:e}:this._payload={...this._payload,exp:v(new Date)+R(e)},this}setIssuedAt(e){return typeof e>"u"?this._payload={...this._payload,iat:v(new Date)}:this._payload={...this._payload,iat:e},this}}class Ee extends be{setProtectedHeader(e){return this._protectedHeader=e,this}async sign(e,r){var n;const o=new Se(y.encode(JSON.stringify(this._payload)));if(o.setProtectedHeader(this._protectedHeader),Array.isArray((n=this._protectedHeader)===null||n===void 0?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&this._protectedHeader.b64===!1)throw new f("JWTs MUST NOT use unencoded payload");return o.sign(e,r)}}const ge=J;function Ae(t){if(typeof t!="string")throw new f("JWTs must use Compact JWS serialization, JWT must be a string");const{1:e,length:r}=t.split(".");if(r===5)throw new f("Only JWTs using Compact JWS serialization can be decoded");if(r!==3)throw new f("Invalid JWT");if(!e)throw new f("JWTs must contain a payload");let n;try{n=ge(e)}catch{throw new f("Failed to parse the base64url encoded payload")}let o;try{o=JSON.parse(b.decode(n))}catch{throw new f("Failed to parse the decoded payload as JSON")}if(!A(o))throw new f("Invalid JWT Claims Set");return o}export{Ee as S,Ae as d,_e as j};
