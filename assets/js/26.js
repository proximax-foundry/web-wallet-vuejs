(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[26],{

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, private, scripts, dependencies, devDependencies, optionalDependencies, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"web-wallet-vuejs\\\",\\\"version\\\":\\\"0.0.11\\\",\\\"private\\\":true,\\\"scripts\\\":{\\\"serve\\\":\\\"vue-cli-service serve\\\",\\\"build\\\":\\\"cross-env NODE_ENV=production vue-cli-service build\\\",\\\"lint\\\":\\\"vue-cli-service lint\\\",\\\"build-development\\\":\\\"cross-env NODE_ENV=development vue-cli-service build\\\",\\\"build-staging\\\":\\\"cross-env NODE_ENV=staging vue-cli-service build\\\",\\\"test\\\":\\\"npx nightwatch --config tests/config/nightwatch.conf.js --headless --no-sandbox tests\\\"},\\\"dependencies\\\":{\\\"@fortawesome/fontawesome-svg-core\\\":\\\"^1.2.34\\\",\\\"@fortawesome/free-solid-svg-icons\\\":\\\"^5.15.2\\\",\\\"@fortawesome/vue-fontawesome\\\":\\\"^3.0.0-3\\\",\\\"@tailwindcss/postcss7-compat\\\":\\\"^2.0.3\\\",\\\"@vueform/multiselect\\\":\\\"^1.5.0\\\",\\\"animate.css\\\":\\\"^4.1.1\\\",\\\"chart.js\\\":\\\"^2.9.4\\\",\\\"cross-env\\\":\\\"^7.0.3\\\",\\\"crypto-js\\\":\\\"^3.3.0\\\",\\\"crypto-random-string\\\":\\\"^4.0.0\\\",\\\"js-joda\\\":\\\"^1.11.0\\\",\\\"js-sha3\\\":\\\"^0.8.0\\\",\\\"jsonwebtoken\\\":\\\"^8.5.1\\\",\\\"maska\\\":\\\"^1.4.1\\\",\\\"mitt\\\":\\\"^2.1.0\\\",\\\"nem-library\\\":\\\"^2.0.0-RC4\\\",\\\"node-sass\\\":\\\"^4.14.1\\\",\\\"postcss\\\":\\\"^7.0.35\\\",\\\"postcss-custom-properties\\\":\\\"^10.0.0\\\",\\\"postcss-nested\\\":\\\"^4.2.3\\\",\\\"primeicons\\\":\\\"^4.1.0\\\",\\\"primevue\\\":\\\"^3.3.4\\\",\\\"rxjs\\\":\\\"^6.6.6\\\",\\\"sass-loader\\\":\\\"^7.3.1\\\",\\\"tailwindcss\\\":\\\"npm:@tailwindcss/postcss7-compat@^2.0.3\\\",\\\"tsjs-xpx-chain-sdk\\\":\\\"^0.8.1\\\",\\\"tslib\\\":\\\"^2.2.0\\\",\\\"v-tooltip\\\":\\\"^4.0.0-alpha.1\\\",\\\"v-wave\\\":\\\"^1.2.8\\\",\\\"vue\\\":\\\"^3.0.0\\\",\\\"vue-currency-input\\\":\\\"^2.0.0-rc.2\\\",\\\"vue-i18n\\\":\\\"^9.1.6\\\",\\\"vue-password\\\":\\\"^3.0.0\\\",\\\"vue-router\\\":\\\"^4.0.0-0\\\",\\\"vue-tippy\\\":\\\"^6.0.0-alpha.29\\\",\\\"vue3-loading-overlay\\\":\\\"0.0.0\\\",\\\"vue3-simple-file-input\\\":\\\"^1.0.3\\\"},\\\"devDependencies\\\":{\\\"@typescript-eslint/eslint-plugin\\\":\\\"^4.18.0\\\",\\\"@typescript-eslint/parser\\\":\\\"^4.18.0\\\",\\\"@vue/cli-plugin-eslint\\\":\\\"~4.5.0\\\",\\\"@vue/cli-plugin-router\\\":\\\"~4.5.0\\\",\\\"@vue/cli-plugin-typescript\\\":\\\"~4.5.0\\\",\\\"@vue/cli-service\\\":\\\"~4.5.0\\\",\\\"@vue/compiler-sfc\\\":\\\"^3.0.0\\\",\\\"@vue/eslint-config-typescript\\\":\\\"^7.0.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"chromedriver\\\":\\\"^91.0.1\\\",\\\"eslint\\\":\\\"^7.28.0\\\",\\\"eslint-plugin-vue\\\":\\\"^7.11.1\\\",\\\"geckodriver\\\":\\\"^2.0.0\\\",\\\"nightwatch\\\":\\\"^1.7.3\\\",\\\"typescript\\\":\\\"~4.1.5\\\"},\\\"optionalDependencies\\\":{\\\"fsevents\\\":\\\">=1.0.0 <2.3.2\\\"}}\");\n\n//# sourceURL=webpack:///./package.json?");

/***/ }),

/***/ "./src/environment/environment.js":
/*!****************************************!*\
  !*** ./src/environment/environment.js ***!
  \****************************************/
/*! exports provided: environment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"environment\", function() { return environment; });\n/* harmony import */ var nem_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nem-library */ \"./node_modules/nem-library/dist/index.js\");\n/* harmony import */ var nem_library__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nem_library__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var js_joda__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-joda */ \"./node_modules/js-joda/dist/js-joda.esm.js\");\n\n\n\n\n\nconst environment = {\n  production: false,\n  routeNodesJson: 'testnet',\n  itemBooksAddress: 'sw-books-testnet',\n  version: '0.5.4',\n  cacheVersion: '01',\n  nameKeyBlockStorage: `sw-blocks`,\n  nameKeyNodeSelected: `sw-selected-node-testnet`,\n  nameKeyWalletStorage: `sw`,\n  nameKeyNodeStorage: `sw-nodes-testnet`,\n  nameKeyNamespaces: `sw-namespaces-testnet`,\n  nameKeyMosaicStorage: `sw-mosaics-testnet`,\n  nameKeyVersion: 'sw-version-testnet',\n  nameKeyWalletTransactionsNis: 'sw-transactions-nis',\n  activeModulesBox: {\n    voting: {\n      viewChildrenParam: true,\n      createPoll: true,\n      vote: true,\n      viewResult: false,\n      classNameParam: ''\n    },\n    storage: {\n      viewChildrenParam: true,\n      files: true,\n      uploadFiles: true,\n      sendShare: false,\n      classNameParam: ''\n    },\n    notarization: {\n      viewChildrenParam: true,\n      attest: true,\n      audit: true,\n      classNameParam: ''\n    },\n  },\n  protocol: `https`,\n  protocolWs: `wss`,\n  nodeExplorer: 'http://bctestnetexplorer.xpxsirius.io/#/result/hash',\n  mosaicXpxInfo: {\n    name: 'prx.xpx',\n    coin: 'XPX',\n    id: '13bfc518e40549d7',\n    mosaicIdUint64: [3825551831, 331334936],\n    namespaceIdUint64: [2434186742, 3220914849],\n    namespaceId: 'bffb42a19116bdf6',\n    divisibility: 6\n  },\n  deadlineTransfer: {\n    deadline: 1439,\n    chronoUnit: js_joda__WEBPACK_IMPORTED_MODULE_2__[\"ChronoUnit\"].MINUTES\n  },\n  timeOutTransactionNis1: 20000,\n  blockchainConnection: {\n    host: 'bctestnet1.brimstone.xpxsirius.io',\n    port: 443,\n    protocol: 'https',\n    useSecureMessage: false\n  },\n  storageConnection: {\n    host: 'ipfs1-dev.xpxsirius.io',\n    port: 80,\n    options: {\n      protocol: 'http'\n    }\n\n  },\n  storageConnectionUnload: {\n    host: 'ipfs1-dev.xpxsirius.io',\n    port: 5001,\n    options: {\n      protocol: 'http'\n    }\n\n  },\n  namespaceRentalFeeSink: {\n    public_key: 'F3B8194C36CC55500DCB8CD3734DFA07FE8B649219BE315C8DFAE1DAC59F3595',\n    address_public_test: 'VBH4NR-KUNINP-7HW6ZB-OECMIN-X3BCB4-ZDXKDM-KIWG'\n  },\n  mosaicRentalFeeSink: {\n    public_key: '640A0DA89F6F57E43C526520AD05C59E185D19ADC95788D8611EBAEC94DEBBA1',\n    address_public_test: 'VD6AXC-3QBCFT-SLKHT6-2UPGTN-V5Z63I-YZKJI3-YGMD'\n  },\n  pollsContent: {\n    public_key: 'A32CC719A9C4524B952F8A357E8103015EB9CA12B08A31497464398D53206669',\n    address_public_test: 'VDB52J-IIE4SA-CUNOOP-N44H66-47O42B-XTPWJH-LPGW'\n  },\n  attestation: {\n    address_public_test: 'VDYN53-XXEGKK-3XHQYE-K6ZBMN-JPXN57-ZBHXA3-AW55'\n  },\n  nis1: {\n    url: 'https://bctestnetswap.xpxsirius.io:7890',\n    // url: 'http://192.168.3.217:7890',\n    urlExplorer: 'http://testnet-explorer.nemtool.com/#/s_tx?hash=',\n    networkType: nem_library__WEBPACK_IMPORTED_MODULE_0__[\"NetworkTypes\"].TEST_NET,\n    burnAddress: 'TBF4LAZUEJMBIOC6J24D6ZGGXE5W775TX555CTTN',\n    nodes: [\n      { protocol: 'https', domain: 'bctestnetswap.xpxsirius.io', port: 7890 } \n    ],\n  },\n  swapAccount: {\n    addressAccountMultisig: 'VAWOEOWTABXR7O3ZAK2XNA5GIBNE6PZIXDAFDWBU',\n    addressAccountSimple: 'VCWAHAMZRKWU4T3MSBEV7CJVYN7TGX5ZCYMVTUJW'\n  },\n  swapAllowedMosaics: [\n    { namespaceId: 'zarcade', name: 'xar', divisibility: 4 },\n    { namespaceId: 'prx', name: 'xpx', divisibility: 6 }\n  ],\n  typeNetwork: {\n    value: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NetworkType\"].TEST_NET,\n    label: 'PUBLIC TEST'\n  },\n  coingecko: {\n    url: 'https://api.coingecko.com/api/v3/coins/',\n  },\n  blockHeightMax: {\n    heightMax: 172800\n  },\n  lockFundDuration: 11520,\n  delayBetweenLockFundABT: 20000,\n  transactionStatusWaitTime: 10000,\n  peerHosting: {\n    host: 'demo-sc-api-1.ssi.xpxsirius.io',\n    port: 443,\n    path: '/peerjs',\n    secure: true,\n    debug: 3\n  }\n};\n\n\n//# sourceURL=webpack:///./src/environment/environment.js?");

/***/ }),

/***/ "./src/store/app.js":
/*!**************************!*\
  !*** ./src/store/app.js ***!
  \**************************/
/*! exports provided: appStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appStore\", function() { return appStore; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _util_listener_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/listener.js */ \"./src/util/listener.js\");\n/* harmony import */ var _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/multiSignatory.js */ \"./src/util/multiSignatory.js\");\n/* harmony import */ var _store_sirius__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/store/sirius */ \"./src/store/sirius.js\");\n\n\n\n\n\n\n\nconst sdk = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n\nconst config = __webpack_require__(/*! @/../config/config.json */ \"./config/config.json\");\nconst walletKey = \"sw\";\nconst name = \"Sirius Wallet\";\n\nconst currentWallet = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(null);\n\nfunction getWallets() {\n  if (!localStorage.getItem(walletKey)) {\n    localStorage.setItem(walletKey, \"[]\");\n  }\n  return JSON.parse(localStorage.getItem(walletKey));\n}\n\nconst state = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])({\n  darkTheme: false,\n  wallets: getWallets(),\n  currentLoggedInWallet: Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => currentWallet.value),\n  loggedInWalletFirstAccount: Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => {\n    if (!currentWallet.value) {\n      return undefined;\n    }\n    return currentWallet.value.accounts.find((element) => element.default);\n  }),\n  isLogin: false,\n});\n\nconst explorerBlockHttp = (compactBlock) => {\n  return `${config.chainExplorer.url}/${config.chainExplorer.blockRoute}/${compactBlock}`;\n};\n\nconst explorerPublicKeyHttp = (publicKey) => {\n  return `${config.chainExplorer.url}/${config.chainExplorer.publicKeyRoute}/${publicKey}`;\n};\n\nfunction toggleDarkTheme() {\n  if (config.debug) {\n    console.log(\"toggleDarkTheme triggered\");\n  }\n\n  state.darkTheme = !state.darkTheme;\n}\n\nfunction isPrivateKeyValid(privateKey) {\n  if (privateKey.length !== 64 && privateKey.length !== 66) {\n    return false;\n  } else if (!tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Convert\"].isHexString(privateKey)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\n// verify private key and password\nfunction verifyExistingAccount(privateKey){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const account = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(privateKey, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType());\n  return (wallet.accounts.findIndex((element) => element.address == account.address.address) >= 0 ) ? true : false ;\n}\n\nfunction getWalletByName(walletName) {\n  walletName =\n    walletName.includes(\" \") === true\n      ? walletName.split(\" \").join(\"_\")\n      : walletName;\n  return state.wallets.find((element) => element.name == walletName && element.networkName === _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.chainNetworkName);\n}\n\nfunction getWalletByNameOnly(walletName) {\n  walletName =\n    walletName.includes(\" \") === true\n      ? walletName.split(\" \").join(\"_\")\n      : walletName;\n  return state.wallets.find((element) => element.name == walletName);\n}\n\nfunction getWalletIndexByName(walletName) {\n  walletName =\n    walletName.includes(\" \") === true\n      ? walletName.split(\" \").join(\"_\")\n      : walletName;\n  return state.wallets.findIndex((element) => element.name == walletName && element.networkName === _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.chainNetworkName);\n}\n\n// with custom network param\nfunction getWalletByNameAndNetwork(walletName, networkName) {\n  walletName = walletName.includes(\" \") === true ? walletName.split(\" \").join(\"_\") : walletName;\n  return state.wallets.find((element) => element.name == walletName && element.networkName === networkName);\n}\n\nfunction getWalletIndexByNameAndNetwork(walletName, networkName = undefined) {\n  let networkNameToCompare = networkName ? networkName : _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.chainNetworkName;\n  walletName =\n    walletName.includes(\" \") === true\n      ? walletName.split(\" \").join(\"_\")\n      : walletName;\n  return state.wallets.findIndex((element) => element.name == walletName && element.networkName === networkNameToCompare);\n}\n\n/* benjamin lai */\nfunction getAccountByWallet(walletName){\n  const wallet = getWalletByName(walletName);\n  const account = wallet.accounts.find((element) => element.default == true);\n  return account;\n}\n\nfunction importWallet(decryptedData, networkName, networkType){\n  let walletName = decryptedData.name;\n  console.log(decryptedData);\n  walletName = (walletName.includes(' ') === true) ? walletName.split(' ').join('_') : walletName;\n  if(getWalletByName(walletName) == undefined){\n    // if (decryptedData.accounts[0].network == network) {\n      const accounts = [];\n      const contacts = [];\n      if (decryptedData.accounts.length !== undefined) {\n        for (let element of decryptedData.accounts) {\n          var newAddress = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromPublicKey(element.publicAccount.publicKey, networkType);\n          element.address = newAddress.plain();\n          element.network = networkType;\n          accounts.push(element);\n        }\n      } else {\n        // invalid without account\n        return 'invalid_wallet';\n      }\n\n      if (decryptedData.contacts.length !== undefined) {\n        for (const element of decryptedData.contacts) {\n          contacts.push(element);\n        }\n      }\n\n      const wallet = {\n        name: walletName,\n        accounts: accounts,\n        contacts: contacts,\n        networkName: networkName,\n      }\n      state.wallets.push(wallet);\n      try {\n        localStorage.setItem(\n          walletKey,\n          JSON.stringify(state.wallets)\n        );\n      } catch (err) {\n        if (config.debug) {\n          console.error(\"importWallet error caught\", err);\n        }\n        return 'invalid_wallet';\n      }\n      return 'wallet_added';\n    // } else {\n    //   // invalid network type error message\n    //   return 'invalid_network';\n    // }\n  } else {\n    // wallet already exist message\n    return 'existed_wallet';\n  }\n}\n\nfunction addNewWallet(networkName, walletName, password, networkType, privateKey) {\n  let wallet = getWalletByName(walletName);\n  if (wallet) {\n    if (config.debug) {\n      console.error(\n        \"addNewWallet triggered with duplicate wallet name\",\n        walletName\n      );\n    }\n    return -1;\n  }\n\n  if (config.debug) {\n    console.log(\"addNewWallet triggered with\", walletName);\n  }\n\n  const encryptedPasswd = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Password\"](password);\n  if (privateKey) {\n    wallet = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"SimpleWallet\"].createFromPrivateKey(\n      walletName,\n      encryptedPasswd,\n      privateKey,\n      networkType\n    );\n  } else {\n    wallet = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"SimpleWallet\"].create(walletName, encryptedPasswd, networkType);\n  }\n\n  const newWallet = {\n    name:\n      walletName.includes(\" \") === true\n        ? walletName.split(\" \").join(\"_\")\n        : walletName,\n    accounts: new Array(),\n    contacts: new Array(),\n    networkName: networkName,\n  };\n\n  const account = wallet.open(encryptedPasswd);\n\n  const address = {\n    address: wallet.address.address,\n    networktype: wallet.network\n  }\n  const publicKey = {\n    publicKey: account.publicKey,\n    address: address\n  };\n\n  newWallet.accounts.push({\n    algo: \"pass:bip32\",\n    brain: true,\n    default: true,\n    firstAccount: true,\n    name: \"Primary\",\n    address: wallet.address.address,\n    publicAccount: publicKey,\n    encrypted: wallet.encryptedPrivateKey.encryptedKey,\n    iv: wallet.encryptedPrivateKey.iv,\n    network: _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType(),\n    balance: 0,\n    isMultisign: null,\n    multisigAccountGraphInfo: null,\n    nis1Account: null,\n    mosaic: null,\n  });\n\n  state.wallets.push(newWallet);\n  try {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"addNewWallet error caught\", err);\n    }\n    return 0;\n  }\n  return account.privateKey;\n}\n\nfunction verifyExistingAccountName(walletName, accountName){\n  const wallet = getWalletByName(walletName);\n  const account = wallet.accounts.find((element) => element.name.toUpperCase() === accountName.toUpperCase().trim().replace(/ /g,\"_\"));\n  return (account) ? 1 : 0;\n}\n\nfunction verifyWalletPassword(walletName, password){\n  const wallet = getWalletByName(walletName);\n  if (!wallet) {\n    if (config.debug) {\n      console.error(\n        \"loginToWallet triggered with invalid wallet name\",\n        walletName\n      );\n    }\n    return -1;\n  }\n\n  if (config.debug) {\n    console.log(\"loginToWallet triggered with\", walletName);\n  }\n\n  const account = wallet.accounts.find((element) => element.default == true);\n\n  const common = {\n    password: password,\n  };\n\n  if (\n    !tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Crypto\"].passwordToPrivateKey(\n      common,\n      account,\n      account.algo == \"pass:bip32\" ? tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"WalletAlgorithm\"].Pass_bip32 : account.algo\n    )\n  ) {\n    console.log('fail');\n    return 0;\n  }\n\n  if (\n    !isPrivateKeyValid(common.privateKey) ||\n    !tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(\n      common.privateKey,\n      account.network\n    ).address.plain() === pretty(account.address)\n  ) {\n    return 0;\n  }\n\n  return 1;\n}\n\nfunction deleteWallet(walletName, networkName) {\n  const walletIndex = getWalletIndexByNameAndNetwork(walletName, networkName);\n  if (walletIndex == -1) {\n    if (config.debug) {\n      console.error(\n        \"deleteWallet triggered with non-existing wallet name\",\n        walletName\n      );\n    }\n    return -1;\n  }\n\n  if (config.debug) {\n    console.log(\"deleteWallet triggered with\", walletName);\n  }\n\n  if (state.wallets.splice(walletIndex, 1).length != 0) {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n    return 1;\n  }\n  return -1;\n}\n\n/* Account section - benjamin lai */\nfunction createNewAccount(walletName, walletPassword){\n  const encryptedPasswd = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Password\"](walletPassword);\n  const account = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"SimpleWallet\"].create(walletName, encryptedPasswd, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType());\n  const acc = account.open(encryptedPasswd);\n  account.publicKey = acc.publicKey;\n  account.privateKey = acc.privateKey;\n  return account;\n}\n\nfunction createNewAccountPrivateKey(walletName, walletPassword, pk){\n  const encryptedPasswd = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Password\"](walletPassword);\n  const account = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"SimpleWallet\"].createFromPrivateKey(\n    walletName,\n    encryptedPasswd,\n    pk,\n    _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType()\n  );\n  const acc = account.open(encryptedPasswd);\n  account.publicKey = acc.publicKey;\n  account.privateKey = acc.privateKey;\n  return account;\n}\n\n// check session to verify page has been refreshed\nfunction checkFromSession(siriusStore){\n  const walletSession = JSON.parse(sessionStorage.getItem('currentWalletSession'));\n  const selectedChainNode = sessionStorage.getItem('selectedChainNode');\n  const selectedNetwork = sessionStorage.getItem('selectedNetwork');\n  // const nodePort = sessionStorage.getItem('nodePort');\n  const selectedNetworkName = sessionStorage.getItem('selectedNetworkName');\n  siriusStore.restoreSiriusStateFromSessionStorage(selectedChainNode, selectedNetwork, selectedNetworkName);\n  if(walletSession){\n    // session is not null - copy to state\n    currentWallet.value = walletSession;\n    state.isLogin = true;\n    Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"stopListening\"])();\n    Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"startListening\"])(currentWallet.value.accounts);\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].updateAccountsMultiSign(walletSession.name);\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].removeUnrelatedMultiSig(walletSession.name);\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].checkToCreateMultiSigAccount(walletSession.name);\n\n    getXPXBalance(walletSession.name, siriusStore).then(() => {\n      sessionStorage.setItem('pageRefresh', 'y');\n    });\n    return true;\n  }else{\n    // return false to remain not sign in\n    sessionStorage.setItem('pageRefresh', 'n');\n    return false;\n  }\n}\n\n// eslint-disable-next-line no-unused-vars\nfunction loginToWallet(walletName, password, siriusStore) {\n  const wallet = getWalletByName(walletName);\n  if (!wallet) {\n    if (config.debug) {\n      console.error(\n        \"loginToWallet triggered with invalid wallet name\",\n        walletName\n      );\n    }\n    return -1;\n  }\n\n  if (config.debug) {\n    console.log(\"loginToWallet triggered with\", walletName);\n  }\n\n  const account = wallet.accounts.find((element) => element.default == true);\n  if (!account) {\n    if (config.debug) {\n      console.error(\"loginToWallet triggered with invalid accounts\", walletName);\n    }\n    return -1;\n  }\n\n  const common = {\n    password: password,\n  };\n\n  if (\n    !tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Crypto\"].passwordToPrivateKey(\n      common,\n      account,\n      account.algo == \"pass:bip32\" ? tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"WalletAlgorithm\"].Pass_bip32 : account.algo\n    )\n  ) {\n    return 0;\n  }\n\n  if (\n    !isPrivateKeyValid(common.privateKey) ||\n    !tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(\n      common.privateKey,\n      account.network\n    ).address.plain() === pretty(account.address)\n  ) {\n    return 0;\n  }\n\n  currentWallet.value = wallet;\n  state.isLogin = true;\n  Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"startListening\"])(wallet.accounts);\n  _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].updateAccountsMultiSign(walletName);\n  _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].removeUnrelatedMultiSig(walletName);\n  _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_3__[\"multiSign\"].checkToCreateMultiSigAccount(walletName);\n  // get latest xpx amount\n  getXPXBalance(walletName, siriusStore).then(()=> {\n    try {\n      sessionStorage.setItem(\n        'currentWalletSession',\n        JSON.stringify(wallet)\n      );\n    } catch (err) {\n      if (config.debug) {\n        console.error(\"updateAccountState error caught\", err);\n      }\n      return 0;\n    }\n    return 1;\n  });\n}\n\nfunction updateWalletConfig(wallet){\n  try {\n    sessionStorage.setItem(\n      'currentWalletSession',\n      JSON.stringify(wallet)\n    );\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"updateAccountState error caught\", err);\n    }\n    return 0;\n  }\n  return 1;\n}\n\nfunction logoutOfWallet() {\n  if (config.debug) {\n    console.error(\"logoutOfWallet triggered\");\n  }\n  Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"stopListening\"])();\n  if (!currentWallet.value) {\n    return false;\n  }\n  state.isLogin = false;\n  currentWallet.value = null;\n  sessionStorage.removeItem('currentWalletSession');\n  return true;\n}\n\n// update state after creating account\n// const account = {\n//   address:\n//   addressPretty:\n//   public:\n//   private:\n// }\nfunction updateAccountState(account, accountName){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  // get wallet index\n  const addressObject = {\n    address: account.address.address,\n    networktype: _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType()\n  };\n  const publicKey = {\n    publicKey: account.publicKey,\n    address: addressObject\n  };\n\n  const acc = {\n    algo: \"pass:bip32\",\n    brain: true,\n    default: false,\n    firstAccount: false,\n    name: accountName.trim().replace(/ /g,\"_\"),\n    address: account.address.address,\n    publicAccount: publicKey,\n    encrypted: account.encryptedPrivateKey.encryptedKey,\n    iv: account.encryptedPrivateKey.iv,\n    network: _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType(),\n    balance: 0,\n    isMultisign: null,\n    multisigAccountGraphInfo: null,\n    nis1Account: null,\n    mosaic: null,\n  };\n\n  wallet.accounts.push(acc);\n  // update currentLoggedInWallet\n  currentWallet.value = wallet;\n\n  // enable listener\n  Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"addListenerstoAccount\"])(acc);\n\n  sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n  // update localStorage\n  try {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"updateAccountState error caught\", err);\n    }\n    return 0;\n  }\n  return 1;\n}\n\nasync function updateCreatedMultiSigToWallet(multisigPublicKey, multisigAddress, cosignerPublicAccount){\n\n  const wallet = getWalletByName(appStore.state.currentLoggedInWallet.name);\n\n  let addressObject = {\n    address: multisigAddress,\n    networktype: _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType()\n  };\n\n  let publicKeyObj = {\n    publicKey: multisigPublicKey,\n    address: addressObject\n  };\n\n  let cosignatories = {\n    cosignatories: [cosignerPublicAccount]\n  }\n\n  let account = {\n    default: false,\n    firstAccount: false,\n    address: multisigAddress,\n    name: 'MULTISIG-' + multisigAddress.substr(-4),\n    publicAccount: publicKeyObj,\n    balance: 0,\n    network: _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType(),\n    isMultisign: cosignatories,\n    multisigAccountGraphInfo: null,\n    nis1Account: null,\n    mosaic: [],\n  };\n\n  wallet.accounts.push(account);\n  // console.log(account)\n  // console.log(wallet)\n  currentWallet.value = wallet;\n  // console.log(currentWallet.value)\n\n  // enable listener\n  Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_2__[\"addListenerstoAccount\"])(account);\n  sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n  // update localStorage\n  try {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"updateAccountState error caught\", err);\n    }\n    return 0;\n  }\n  return 1;\n}\n\nfunction updateAccountName(name, address){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const exist_account = wallet.accounts.find((element) => element.name == name.trim());\n  const exist_account_index = wallet.accounts.findIndex((element) => element.name == name.trim());\n  const account_index = wallet.accounts.findIndex((element) => element.address == address);\n\n  if(exist_account && (exist_account_index != account_index)){\n    return 2;\n  }\n\n  // get account\n  const account = wallet.accounts.find((element) => element.address == address);\n  if (!account) {\n    if (config.debug) {\n      console.error(\"updateAccountName triggered with invalid account name\");\n    }\n    return -1;\n  }\n  account.name = name.trim().replace(/ /g,\"_\");\n  sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n  // update localStorage\n  try {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"updateAccountState error caught\", err);\n    }\n    return 0;\n  }\n  return 1;\n}\n\nfunction setAccountDefault(address){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  wallet.accounts.map(x => {x.default = false;});\n  // set account with the address as default\n  const account = wallet.accounts.find((element) => element.address == address);\n  account.default = true;\n  currentWallet.value = wallet;\n  sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n  // update localStorage\n  try {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"updateAccountState error caught\", err);\n    }\n    return 0;\n  }\n  return 1;\n}\n\nfunction getAccDetails(name){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const account = wallet.accounts.find((element) => element.name == name);\n  if (!account) {\n    if (config.debug) {\n      console.error(\"getAccDetails triggered with invalid account name\");\n    }\n    return -1;\n  }\n  return account;\n}\n\nfunction getAccDetailsByAddress(address){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const account = wallet.accounts.find((element) => element.address == address);\n  if (!account) {\n    if (config.debug) {\n      console.error(\"getAccDetails triggered with invalid account address\");\n    }\n    return -1;\n  }\n  return account;\n}\n\nfunction getAccountPassword(accountName, password){\n  const account = getAccDetails(accountName);\n  return decryptPrivateKey(password, account.encrypted, account.iv);\n}\n\nfunction deleteAccount(address) {\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const accountIndex = wallet.accounts.findIndex((element) => element.address == address);\n  const account = getAccDetailsByAddress(address);\n\n  if (accountIndex < 0) {\n    if (config.debug) {\n      console.error(\"deleteAccount triggered with non-existing account name\");\n    }\n    return -1;\n  }\n\n  // check if this account is the cosign of any multisig in the same wallet\n  if(account.isMultisign != undefined){\n    if(account.isMultisign.multisigAccounts != undefined){\n      account.isMultisign.multisigAccounts.forEach((multisig) => {\n        // check if there's other cosigner in the wallet before deleting\n        const multiSigAccount = getAccDetailsByAddress(multisig.address.address);\n        let isDeleteMultiSig = true;\n        if(!multiSigAccount){\n          if(multiSigAccount.isMultisign.cosignatories != undefined){\n            if(multiSigAccount.isMultisign.cosignatories.length > 1){\n              multiSigAccount.isMultisign.cosignatories.forEach((cosigner) => {\n                if(cosigner.address.address != address && getAccDetailsByAddress(cosigner.address.address)){\n                  // can't delete when there is another cosigner in the wallet\n                  isDeleteMultiSig = false;\n                }\n              });\n            }\n          }\n        }\n        if(isDeleteMultiSig){\n          const multiSigIndex = wallet.accounts.findIndex((element) => element.address == multisig.address.address);\n          wallet.accounts.splice(multiSigIndex, 1);\n        }\n      });\n    }\n  }\n\n  if (wallet.accounts.splice(accountIndex, 1).length != 0) {\n    currentWallet.value = wallet;\n    sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n    return 1;\n  }\n  return -1;\n}\n\nfunction removeMultiSigAccount(accounts){\n  if(accounts.length > 0){\n    const wallet = getWalletByName(state.currentLoggedInWallet.name);\n    accounts.forEach((multisig) => {\n      const accountIndex = wallet.accounts.findIndex((element) => element.address === multisig.address );\n      // console.log('Remove index: ' + accountIndex + ' ' + multisig.address);\n      wallet.accounts.splice(accountIndex, 1);\n    });\n    currentWallet.value = wallet;\n    sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n  }\n}\n\nfunction getCurrentAdd(walletName){\n  const wallet = getWalletByName(walletName);\n  const account = wallet.accounts.find((element) => element.default == true);\n  return account.address;\n}\n\nfunction saveContact(contactName, contactAddress){\n  contactAddress = contactAddress.split('-').join('')\n  // verify address and name\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  // check for existing account address in wallet\n  const accountAddIndex = wallet.accounts.findIndex((element) => element.address == contactAddress);\n  // check for existing account name in wallet\n  const accountNameIndex = wallet.accounts.findIndex((element) => element.name.toLowerCase() == contactName.toLowerCase());\n  const contactAddIndex = (wallet.contacts!=undefined)?wallet.contacts.findIndex((element) => element.address == contactAddress):(-1);\n  const contactNameIndex =(wallet.contacts!=undefined)?wallet.contacts.findIndex((element) => element.name.toLowerCase() == contactName.toLowerCase()):(-1);\n  const errMsg = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])('');\n\n  if(contactAddIndex >= 0 || accountAddIndex >= 0 || contactNameIndex >= 0 || accountNameIndex >= 0 ){\n    errMsg.value = 'Address or Name already exist';\n  }\n\n  if(wallet.contacts == undefined){\n    wallet.contacts = [];\n  }\n\n  if(!errMsg.value){\n    // add into contact list\n    wallet.contacts.push({\n      name: contactName,\n      address: contactAddress,\n    });\n    sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n    // update localStorage\n    try {\n      localStorage.setItem(\n        walletKey,\n        JSON.stringify(state.wallets)\n      );\n    } catch (err) {\n      if (config.debug) {\n        console.error(\"saveContact error caught\", err);\n      }\n      return 0;\n    }\n    return true;\n  }else{\n    return errMsg.value;\n  }\n}\n\nfunction fetchAccountInfo(wallet, accountHttp){\n  const addresses = [];\n  wallet.accounts.forEach((element) => {\n    addresses.push(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromPublicKey(element.publicAccount.publicKey, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].getNetworkType()));\n  });\n\n  return new Promise((resolve, reject) => {\n    try{\n      accountHttp.getAccountsInfo(addresses).subscribe(accountInfo => {\n        resolve(accountInfo);\n      }, error => {\n        console.warn(error);\n        reject(false);\n      });\n    }catch(err){\n      console.warn(err);\n      reject(false);\n    }\n  });\n}\n\nfunction getTotalBalance(){\n  const wallet = getWalletByName(appStore.state.currentLoggedInWallet.name);\n  let balance = 0;\n  wallet.accounts.forEach((item) => {\n    balance += parseFloat(item.balance);\n  });\n  return balance.toFixed(6);\n}\n\n// get XPX balance for each account in the current logged in wallet and update state\nfunction getXPXBalance(walletName, siriusStore){\n\n  const wallet = getWalletByName(walletName);\n  const xpxNamespace = new sdk.NamespaceId('prx.xpx');\n  let xpxAmount = 0;\n  return new Promise((resolve) => {\n    fetchAccountInfo(wallet, siriusStore.accountHttp).then((res)=>{\n      wallet.accounts.forEach((add) => {\n        const account = wallet.accounts.find((e) => e.address == add.address);\n        account.mosaic = [];\n        const mosaicList = [];\n        const mosaicAmount = [];\n        const address = res.find((element) => element.address.address == add.address);\n        if(address != undefined){\n\n          siriusStore.namespaceHttp.getLinkedMosaicId(xpxNamespace).subscribe((xpxMosaicId) => {\n\n            for(const mosaic of address.mosaics){\n              if(mosaic.id.toHex() === xpxMosaicId.toHex() ){\n                xpxAmount = mosaic.amount.compact() / Math.pow(10, sdk.XpxMosaicProperties.MOSAIC_PROPERTIES.divisibility);\n              }else{\n                mosaicList.push(mosaic.id);\n                mosaicAmount[mosaic.id.toHex()] = mosaic.amount.compact();\n              }\n            }\n            siriusStore.mosaicHttp.getMosaics(mosaicList).subscribe((mosaicInfo) => {\n              mosaicInfo.forEach((mosaic) => {\n                account.mosaic.push({ id: mosaic.mosaicId.toHex(), amount: mosaicAmount[mosaic.mosaicId.toHex()]/Math.pow(10, mosaic.divisibility), divisibility: mosaic.divisibility })\n              })\n            }, error => {\n                console.error(error);\n            }, () => {\n                // console.log('Get balance of ' + add.address );\n            })\n            account.balance = String(parseFloat(xpxAmount).toFixed(6));\n          });\n        }else{\n          account.balance = 0;\n        }\n      });\n      resolve(wallet);\n    });\n  });\n}\n\nfunction updateXPXBalance(walletName, siriusStore){\n  // get latest xpx amount\n  getXPXBalance(walletName, siriusStore).then(()=> {\n    try {\n      const wallet = getWalletByName(walletName);\n      currentWallet.value = wallet;\n      sessionStorage.setItem('currentWalletSession', JSON.stringify(wallet));\n      localStorage.setItem(walletKey, JSON.stringify(state.wallets));\n    } catch (err) {\n      if (config.debug) {\n        console.error(\"updateAccountState error caught\", err);\n      }\n      return 0;\n    }\n    return 1;\n  });\n}\n\nfunction getFirstAccName(){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const acc = wallet.accounts.find((element) => element.default == true);\n  return acc.name;\n}\n\nfunction getFirstAccAdd(){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const acc = wallet.accounts.find((element) => element.default == true);\n  return acc.address;\n}\n\nfunction getBalanceByAddress(address){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const acc = wallet.accounts.find((element) => element.address == address);\n  return acc.balance;\n}\n\nfunction getFirstAccBalance(){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const acc = wallet.accounts.find((element) => element.default == true);\n  return acc.balance;\n}\n\nfunction displayBalance(){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  if(wallet.accounts.length == 1){\n    let amount = 0;\n    wallet.accounts.forEach((element)=> {\n      amount = element.balance;\n    });\n    return amount;\n  }\n}\n\n// return mosaic divisibility\nfunction getMosaicInfo(address, mosaicId){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const account = wallet.accounts.find((element) => element.address == address);\n  const mosaic = account.mosaic.find((element) => element.id == mosaicId);\n  return mosaic;\n}\n\n\nfunction getContact(){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  var contact = [];\n  wallet.accounts.forEach((element) => {\n    contact.push({\n      value: element.address,\n      label: element.name + ' - Owner account',\n    });\n  });\n  if(wallet.contacts!=undefined){\n    wallet.contacts.forEach((element) => {\n      contact.push({\n        value: element.address,\n        label: element.name + ' - Contact',\n      });\n    });\n  }\n  return contact;\n}\n\nfunction verifyPublicKey(add, accountHttp){\n  const invalidPublicKey = '0000000000000000000000000000000000000000000000000000000000000000';\n  let address;\n  address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(add.toLocaleUpperCase());\n  return new Promise((resolve) => {\n    const accountInfo = accountHttp.getAccountInfo(address);\n    accountInfo.subscribe(\n      (acc) => {\n        if (acc.publicKey === invalidPublicKey) {\n          console.warn(`The receiver's public key is not valid for sending encrypted messages`);\n          resolve(true)\n        }\n        resolve(false);\n      },\n      (error) => {\n        console.warn('Err: ' + error);\n        resolve(true);\n      }\n    );\n  });\n}\n\nfunction verifyRecipientInfo(recipient,accountHttp) {\n  return new Promise((resolve, reject) => {\n    verifyPublicKey(recipient, accountHttp).then((res) => {\n      resolve(res);\n    }).catch(function(error) {\n      // handle error\n      reject(\"Error is: \" + error);\n    })\n  });\n}\n\nfunction checkAvailableContact(recipient){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  let isInContacts = true;\n  if(wallet.contacts != undefined){\n    isInContacts = (wallet.contacts.findIndex((element) => element.address == recipient) == -1);\n  }\n  return ( isInContacts && (wallet.accounts.findIndex((element) => element.address == recipient) == -1))?false:true;\n}\n\nfunction pretty(address){\n  return address.replace(/([a-zA-Z0-9]{6})([a-zA-Z0-9]{6})([a-zA-Z0-9]{6})([a-zA-Z0-9]{6})([a-zA-Z0-9]{6})([a-zA-Z0-9]{6})([a-zA-Z0-9]{4})/, \"$1-$2-$3-$4-$5-$6-$7\");\n}\n\nfunction decryptPrivateKey(password, encryptedKey, iv) {\n  const common = {\n    password: password,\n    privateKey: ''\n  };\n\n  const wallet = {\n    encrypted: encryptedKey,\n    iv,\n  };\n  tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Crypto\"].passwordToPrivateKey(common, wallet, tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"WalletAlgorithm\"].Pass_bip32);\n  return common.privateKey;\n}\n\nfunction deleteContact(contact){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const contactIndex = wallet.contacts.findIndex((element) => element.name == contact.name && element.address == contact.address);\n  if (wallet.contacts.splice(contactIndex, 1).length != 0) {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n    return 1;\n  }\n  return -1;\n}\n\nfunction editContact(originalContact, contactName, contactAddress){\n  const wallet = getWalletByName(state.currentLoggedInWallet.name);\n  const contactIndex = wallet.contacts.findIndex((element) => element.name == originalContact.name && element.address == originalContact.address);\n  if (wallet.contacts.splice(contactIndex, 1).length != 0) {\n    localStorage.setItem(\n      walletKey,\n      JSON.stringify(state.wallets)\n    );\n    let status = saveContact(contactName, contactAddress);\n    if(status === true){\n      return true;\n    }else{\n      return status;\n    }\n  }\n  return -1;\n}\n\nconst appStore = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])({\n  name,\n  version: __webpack_require__(/*! @/../package.json */ \"./package.json\").version,\n  state,\n  explorerBlockHttp,\n  explorerPublicKeyHttp,\n  toggleDarkTheme,\n  importWallet,\n  addNewWallet,\n  deleteWallet,\n  createNewAccount,\n  createNewAccountPrivateKey,\n  loginToWallet,\n  logoutOfWallet,\n  getWalletByName,\n  getWalletIndexByName,\n  getWalletByNameAndNetwork,\n  getAccountByWallet,\n  checkFromSession,\n  getTotalBalance,\n  verifyExistingAccountName,\n  verifyWalletPassword,\n  updateAccountState,\n  setAccountDefault,\n  getAccDetails,\n  getAccDetailsByAddress,\n  updateAccountName,\n  deleteAccount,\n  getCurrentAdd,\n  saveContact,\n  getContact,\n  displayBalance,\n  getFirstAccName,\n  getFirstAccAdd,\n  getFirstAccBalance,\n  getBalanceByAddress,\n  verifyRecipientInfo,\n  // makeTransaction,\n  checkAvailableContact,\n  getMosaicInfo,\n  updateXPXBalance,\n  pretty,\n  decryptPrivateKey,\n  getAccountPassword,\n  verifyExistingAccount,\n  verifyPublicKey,\n  updateCreatedMultiSigToWallet,\n  removeMultiSigAccount,\n  deleteContact,\n  editContact,\n  getXPXBalance,\n  getWalletByNameOnly,\n  updateWalletConfig,\n});\n\n\n\n//# sourceURL=webpack:///./src/store/app.js?");

/***/ }),

/***/ "./src/store/sirius.js":
/*!*****************************!*\
  !*** ./src/store/sirius.js ***!
  \*****************************/
/*! exports provided: siriusStore, ChainNetwork, chainNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"siriusStore\", function() { return siriusStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainNetwork\", function() { return ChainNetwork; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chainNetwork\", function() { return chainNetwork; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _storeClasses__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storeClasses */ \"./src/store/storeClasses.js\");\n// import utils from \"@/utils\";\n\n\n\n\nconst config = __webpack_require__(/*! @/../config/config.json */ \"./config/config.json\");\n\nfunction getChainNodes() {\n  const existingNodes = localStorage.getItem(config.localStorage.chainNodesKey);\n  return existingNodes ? JSON.parse(existingNodes) : config.chainNodes;\n}\n\n// function formatNetwork(){\n//   var n = [];\n//   for(var i = 0; i < config.network.length; ++i){\n//     n.push({ value: config.network[i].type, label: config.network[i].name, id: (i+1)});\n//   }\n//   return n;\n// }\n\nfunction getNetworkByType(typeid){\n  return config.network.find((element) => element.type == typeid);\n}\n\n// function getNetworkByName(name){\n//   return config.network.find((element) => element.name == name);\n// }\n\n// ALWAYS use function selectNewChainNode to change currentChainNode value, to avoid web socket listening on old node\n// const currentChainNode = ref(getChainNodes()[0]);\nconst listenerChainWS = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(null);\n\nconst state = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])({\n  chainNodes: getChainNodes(),\n  // network: config.network,\n  // network: formatNetwork(),\n  // selectedChainNode: computed(() =>\n  //   utils.parseNodeConfig(currentChainNode.value)\n  // ),\n  selectedChainNode: '',\n  selectedNetwork: '',\n  chainNetwork: 0,\n  chainNetworkName:'',\n  currentNetworkProfile: {},\n  currentNetworkProfileConfig: {},\n  networkAPIEndpoints: [],\n  availableNetworks: [],\n  blockHeight: '',\n});\n\nfunction _buildAPIEndpointURL(url, port = undefined){\n  var portNumber;\n  if(port){\n    portNumber = port;\n  }\n  else if(state.currentNetworkProfile.httpPort){\n    portNumber = state.currentNetworkProfile.httpPort;\n  }\n  return location.protocol=='https:' ? `https://${url}` : `http://${url}:${portNumber}`;\n}\n\nconst accountHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"AccountHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst blockHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"BlockHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst chainHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ChainHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst chainConfigHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ChainConfigHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst networkHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NetworkHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst nodeHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NodeHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst mosaicHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MosaicHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst transactionHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\nconst namespaceHttp = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NamespaceHttp\"](_buildAPIEndpointURL(state.selectedChainNode)));\n\nconst chainWSListener = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(() => {\n  if (listenerChainWS.value == null) {\n    // console.log('open new socket')\n    listenerChainWS.value = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Listener\"](chainNetworkInstance.buildWSEndpointURL(state.selectedChainNode), WebSocket);\n  }\n  return listenerChainWS.value;\n});\n\nasync function addChainNode(nodeConfigString) {\n  const newNodeConfig = JSON.parse(nodeConfigString);\n  if (config.debug) {\n    console.log(\"addChainNode triggered with\", newNodeConfig.hostname);\n  }\n\n  if (\n    state.chainNodes.find(\n      (element) =>\n        element.protocol == newNodeConfig.protocol &&\n        element.hostname == newNodeConfig.hostname &&\n        element.port == newNodeConfig.port\n    )\n  ) {\n    return -1;\n  }\n\n  try {\n    const http = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"BlockHttp\"](utils.parseNodeConfig(newNodeConfig));\n    const blockInfo = await http.getBlockByHeight(1).toPromise();\n    if (\n      blockInfo.generationHash.toUpperCase() !=\n      config.network.generationHash.toUpperCase()\n    ) {\n      return 0;\n    }\n\n    state.chainNodes.unshift({\n      protocol: newNodeConfig.protocol,\n      hostname: newNodeConfig.hostname,\n      port: newNodeConfig.port,\n    });\n    localStorage.setItem(\n      config.localStorage.chainNodesKey,\n      JSON.stringify(state.chainNodes)\n    );\n    return 1;\n  } catch (err) {\n    if (config.debug) {\n      console.error(\"addChainNode error caught\", err);\n    }\n    return 0;\n  }\n}\n\nfunction selectNewChainNode(nodeConfigString) {\n  const nodeConfig = JSON.parse(nodeConfigString);\n  const found = state.chainNodes.find(\n    (element) =>\n      element.protocol == nodeConfig.protocol &&\n      element.hostname == nodeConfig.hostname &&\n      element.port == nodeConfig.port\n  );\n\n  if (!found) {\n    if (config.debug) {\n      console.error(\n        \"selectNewChainNode triggered with invalid node url\",\n        nodeConfig.hostname\n      );\n    }\n    return false;\n  }\n\n  if (config.debug) {\n    console.log(\"selectNewChainNode triggered with\", nodeConfig.hostname);\n  }\n  // currentChainNode.value = found;\n  stopChainWSListener();\n  return true;\n}\n\nfunction stopChainWSListener() {\n  console.log(\"stopChainWSListener triggered\");\n\n  if (listenerChainWS.value != null) {\n    listenerChainWS.value.terminate();\n    listenerChainWS.value = null;\n  }\n}\n\nfunction getSelectedNetworkSessionStorage(){\n  return sessionStorage.getItem('selectedNetworkName');\n}\n\n// update session storage for network\nfunction updateNetworkSessionStorage(networkId){\n  sessionStorage.setItem('selectedNetwork', networkId);\n  state.chainNetworkName = state.availableNetworks[networkId];\n  sessionStorage.setItem('selectedNetworkName', state.chainNetworkName);\n  chainNetworkInstance.updateCurrentProfile();\n  chainNetworkInstance.updateCurrentProfileConfig();\n}\n\nfunction restoreSiriusStateFromSessionStorage(selectedChainNode, selectedNetwork, selectedNetworkName){\n  state.chainNetworkName = selectedNetworkName;\n  state.selectedChainNode = selectedChainNode;\n  state.chainNetwork = selectedNetwork;\n  chainNetworkInstance.updateCurrentProfile();\n  chainNetworkInstance.updateCurrentProfileConfig();\n}\n\nconst siriusStore = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])({\n  state,\n  // currentChainNode,\n  getChainNodes,\n  // getNetworkByName,\n  accountHttp,\n  blockHttp,\n  chainHttp,\n  chainConfigHttp,\n  networkHttp,\n  mosaicHttp,\n  transactionHttp,\n  namespaceHttp,\n  nodeHttp,\n  chainWSListener,\n  addChainNode,\n  selectNewChainNode,\n  stopChainWSListener,\n  getNetworkByType,\n  _buildAPIEndpointURL,\n  updateNetworkSessionStorage,\n  getSelectedNetworkSessionStorage,\n  restoreSiriusStateFromSessionStorage,\n});\n\nObject(vue__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])( () => state.currentNetworkProfile, (newValues) => {\n  state.networkAPIEndpoints = chainNetworkInstance.formatNetwork();\n  var chainProfilePreferences = new _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfilePreferences\"]( state.chainNetworkName + \"_preferences\");\n  chainProfilePreferences.init();\n  let endpoints = chainNetworkInstance.getChainNodes();\n\n  if(chainProfilePreferences.apiNode && endpoints.includes(chainProfilePreferences.apiNode)){\n    state.selectedChainNode = chainProfilePreferences.apiNode;\n  }\n  else{\n    if(endpoints.length > 0){\n      var randomAPINodeIndex = Math.floor(Math.random() * endpoints.length);\n      chainProfilePreferences.apiNode = endpoints[randomAPINodeIndex];\n      chainProfilePreferences.saveToLocalStorage();\n\n      state.selectedChainNode = endpoints[randomAPINodeIndex];\n    }\n    else{\n      state.selectedChainNode = \"\";\n    }\n  }\n  sessionStorage.setItem('nodePort', newValues.httpPort);\n  sessionStorage.setItem('selectedChainNode', state.selectedChainNode);\n}, {deep: true});\n\nObject(vue__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])( ()=> state.availableNetworks, (newValues) => {\n  let selectedNetwork = 0;\n  //let selectedNetworkName = \"\";\n  let sessionSelectedNetwork = sessionStorage.getItem(\"selectedNetwork\") ? parseInt(sessionStorage.getItem(\"selectedNetwork\")) : 0;\n  //let sessionSelectedNetworkName = sessionStorage.getItem(\"selectedNetworkName\") ? sessionStorage.getItem(\"selectedNetworkName\") : \"\";\n  let lastAccessNetwork = localStorage.getItem(\"lastAccessNetwork\") ? parseInt(localStorage.getItem(\"lastAccessNetwork\")) : 0;\n  //let lastAccessNetworkName = localStorage.getItem(\"lastAccessNetworkName\") ? localStorage.getItem(\"lastAccessNetwork\") : \"\";\n\n  if(sessionSelectedNetwork){\n    selectedNetwork = parseInt(sessionSelectedNetwork);\n    //selectedNetworkName = sessionSelectedNetworkName;\n  }\n  else{\n    selectedNetwork = lastAccessNetwork;\n    //selectedNetworkName = lastAccessNetworkName;\n  }\n\n  if(newValues[selectedNetwork] === undefined){\n    selectedNetwork = 0;\n  }\n  /*\n  else if(newValues[selectedNetwork] !== selectedNetworkName){\n    selectedNetwork = 0;\n  }\n  */\n  state.chainNetwork = selectedNetwork;\n});\n\nObject(vue__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])( ()=> state.chainNetwork, (newValues) => {\n  updateNetworkSessionStorage(newValues);\n});\n\n// chainNode class\nclass ChainNetwork{\n  constructor() {\n    this.httpPort = 3000;\n    this.getSelectedNetwork();\n  }\n\n  getSelectedNetwork(){\n    const selectedNetwork = sessionStorage.getItem('selectedNetwork') ? parseInt(sessionStorage.getItem('selectedNetwork')) : -1;\n    if(selectedNetwork >= 0){\n      state.selectedNetwork = parseInt(sessionStorage.getItem('selectedNetwork'));\n    }\n  }\n\n  updateChainNetwork(network){\n    state.chainNetwork = network;\n  }\n\n  refreshAvailableNetwork(){\n    let names = _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfileNames\"].createDefault().names;\n\n    state.availableNetworks = names;\n  }\n\n  updateAvailableNetworks(){\n    let names = _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfileNames\"].createDefault().names;\n    if(names.length === 0){\n      console.log(\"Is empty\");\n      setTimeout(()=>{\n        this.updateAvailableNetworks();\n      }, 50);\n    }\n    else{\n      state.availableNetworks = names;\n    }\n  }\n\n  updateCurrentProfile(){\n    let profile = state.chainNetworkName ? new _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfile\"](state.chainNetworkName) : null;\n    if(profile){\n      profile.init();\n      state.currentNetworkProfile = profile;\n      // console.log(state.currentNetworkProfile)\n    }\n  }\n\n  updateCurrentProfileConfig(){\n    let profileConfig = state.chainNetworkName ? new _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfileConfig\"](state.chainNetworkName + '_config') : null;\n\n    if(profileConfig){\n      profileConfig.init();\n      state.currentNetworkProfileConfig = profileConfig;\n      // console.log('state.currentNetworkProfileConfig')\n      // console.log(state.currentNetworkProfileConfig)\n    }\n  }\n\n  getCurrentProfile(){\n    return state.currentNetworkProfile;\n  }\n\n  getCurrentProfileConfig(){\n    return state.currentNetworkProfileConfig;\n  }\n\n  refreshselectedNetwork() {\n    state.chainNetwork = sessionStorage.getItem('selectedNetwork');\n  }\n\n  // another declared in siriusStore\n  getChainNodes() {\n    return state.currentNetworkProfile.apiNodes ? state.currentNetworkProfile.apiNodes : [];\n  }\n\n  getProfileConfig() {\n    return state.currentNetworkProfileConfig ? state.currentNetworkProfileConfig : null;\n  }\n\n  getProfileNetwork(){\n    return this.getCurrentProfile().network;\n  }\n\n  getCurrency(){\n    return this.getProfileNetwork().currency;\n  }\n\n  getCurrencyDivisibility(){\n    return this.getCurrency().divisibility;\n  }\n\n  getCurrencyName(){\n    return this.getCurrency().name;\n  }\n\n  getNetworkPort(){\n    return state.currentNetworkProfile.httpPort;\n  }\n\n  getNetworkType(){\n    return state.currentNetworkProfile.network.type;\n  }\n\n  formatNetwork(){\n    var list = this.getChainNodes();\n    var n = [];\n    for(var i = 0; i < list.length; ++i){\n      n.push(this.buildAPIEndpointURL(list[i]));\n    }\n    return n;\n  }\n\n  // getNetworkByType(typeid){\n  //   return config.network.find((element) => element.type == typeid);\n  // }\n\n  static buildChainConfigHttp(apiURL){\n    return new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ChainConfigHttp\"](apiURL);\n  }\n\n  static buildChainHttp(apiURL){\n    return new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ChainHttp\"](apiURL);\n  }\n\n  static async getChainConfig(chainHeight, chainConfigHttp){\n    return new Promise((resolve, reject)=>{\n      chainConfigHttp.getChainConfig(chainHeight).subscribe((configString)=>{\n        var regex = /[^=\\n{1}]+=\\s*(.*)/g;\n        var configs = configString.networkConfig.match(regex);\n        var networkConfig = configs.reduce((result, data)=>{\n          var [config, value] = data.split(\"=\");\n          result[config.trim()] = value.trim();\n          return result;\n        }, {});\n        const chainConfig = {\n          publicKey: networkConfig['publicKey'],\n          blockGenerationTargetTime: networkConfig['blockGenerationTargetTime'],\n          blockTimeSmoothingFactor: ChainNetwork.convertConfigNumberToInteger(networkConfig['blockTimeSmoothingFactor']),\n          greedDelta: Number(networkConfig['greedDelta']),\n          greedExponent: Number(networkConfig['greedExponent']),\n          importanceGrouping: ChainNetwork.convertConfigNumberToInteger(networkConfig['importanceGrouping']),\n          maxRollbackBlocks: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxRollbackBlocks']),\n          maxDifficultyBlocks: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxDifficultyBlocks']),\n          maxTransactionLifetime: networkConfig['maxTransactionLifetime'],\n          maxBlockFutureTime: networkConfig['maxBlockFutureTime'],\n          maxMosaicAtomicUnits: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMosaicAtomicUnits']),\n          totalChainImportance: ChainNetwork.convertConfigNumberToInteger(networkConfig['totalChainImportance']),\n          minHarvesterBalance: ChainNetwork.convertConfigNumberToInteger(networkConfig['minHarvesterBalance']),\n          harvestBeneficiaryPercentage: ChainNetwork.convertConfigNumberToInteger(networkConfig['harvestBeneficiaryPercentage']),\n          blockPruneInterval: ChainNetwork.convertConfigNumberToInteger(networkConfig['blockPruneInterval']),\n          maxTransactionsPerBlock: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxTransactionsPerBlock']),\n          maxTransactionsPerAggregate: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxTransactionsPerAggregate']),\n          maxCosignaturesPerAggregate: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxCosignaturesPerAggregate']),\n          enableStrictCosignatureCheck: networkConfig['enableStrictCosignatureCheck'] === 'true' ? true : false,\n          enableBondedAggregateSupport: networkConfig['enableBondedAggregateSupport'] === 'true' ? true : false,\n          maxBondedTransactionLifetime: networkConfig['maxBondedTransactionLifetime'],\n          maxBlockChainConfigSize: networkConfig['maxBlockChainConfigSize'],\n          maxSupportedEntityVersionsSize: networkConfig['maxSupportedEntityVersionsSize'],\n          minPercentageOfApproval: ChainNetwork.convertConfigNumberToInteger(networkConfig['minPercentageOfApproval']),\n          minPercentageOfRemoval: ChainNetwork.convertConfigNumberToInteger(networkConfig['minPercentageOfRemoval']),\n          maxOfferDuration: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxOfferDuration']),\n          longOfferKey: networkConfig['longOfferKey'],\n          lockedFundsPerAggregate: ChainNetwork.convertConfigNumberToInteger(networkConfig['lockedFundsPerAggregate']),\n          maxHashLockDuration: networkConfig['maxHashLockDuration'],\n          maxSecretLockDuration: networkConfig['maxSecretLockDuration'],\n          minProofSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['minProofSize']),\n          maxProofSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxProofSize']),\n          maxFields: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxFields']),\n          maxFieldKeySize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxFieldKeySize']),\n          maxFieldValueSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxFieldValueSize']),\n          maxMosaicsPerAccount: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMosaicsPerAccount']),\n          maxMosaicDuration: networkConfig['maxMosaicDuration'],\n          maxMosaicDivisibility: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMosaicDivisibility']),\n          mosaicRentalFeeSinkPublicKey: networkConfig['mosaicRentalFeeSinkPublicKey'],\n          mosaicRentalFee: ChainNetwork.convertConfigNumberToInteger(networkConfig['mosaicRentalFee']),\n          maxMultisigDepth: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMultisigDepth']),\n          maxCosignersPerAccount: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxCosignersPerAccount']),\n          maxCosignedAccountsPerAccount: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxCosignedAccountsPerAccount']),\n          newCosignersMustApprove: networkConfig['newCosignersMustApprove'] === 'true' ? true : false,\n          maxNameSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxNameSize']),\n          maxNamespaceDuration: networkConfig['maxNamespaceDuration'],\n          namespaceGracePeriodDuration: networkConfig['namespaceGracePeriodDuration'],\n          reservedRootNamespaceNames: networkConfig['reservedRootNamespaceNames'],\n          namespaceRentalFeeSinkPublicKey: networkConfig['namespaceRentalFeeSinkPublicKey'],\n          rootNamespaceRentalFeePerBlock: ChainNetwork.convertConfigNumberToInteger(networkConfig['rootNamespaceRentalFeePerBlock']),\n          childNamespaceRentalFee: ChainNetwork.convertConfigNumberToInteger(networkConfig['childNamespaceRentalFee']),\n          maxChildNamespaces: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxChildNamespaces']),\n          maxOperationDuration: networkConfig['maxOperationDuration'],\n          maxPropertyValues: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxPropertyValues']),\n          maxMessageSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMessageSize']),\n          maxMosaicsSize: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxMosaicsSize']),\n          minUpgradePeriod: ChainNetwork.convertConfigNumberToInteger(networkConfig['minUpgradePeriod']),\n          maxFilesOnDrive: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxFilesOnDrive']),\n          verificationFee: ChainNetwork.convertConfigNumberToInteger(networkConfig['verificationFee']),\n          verificationDuration: ChainNetwork.convertConfigNumberToInteger(networkConfig['verificationDuration']),\n          downloadDuration: ChainNetwork.convertConfigNumberToInteger(networkConfig['downloadDuration']),\n          downloadCacheEnabled: networkConfig['downloadCacheEnabled'] === 'true' ? true : false,\n          maxSuperContractsOnDrive: ChainNetwork.convertConfigNumberToInteger(networkConfig['maxSuperContractsOnDrive']),\n        };\n        resolve(chainConfig);\n      },\n      (error)=>{\n        reject(error);\n      });\n    });\n  }\n\n  static convertConfigNumberToInteger(amount){\n    if(!amount){\n      return 0;\n    }\n    return parseInt(amount.split(\"'\").join(\"\"));\n  }\n\n  async getChainHeight(chainHttp){\n    return new Promise((resolve, reject)=>{\n      chainHttp.getBlockchainHeight().subscribe((height)=>{\n        const chainHeight = height.compact();\n        resolve(chainHeight);\n      },\n      (error)=>{\n        reject(error);\n      });\n    });\n  }\n\n  buildAPIEndpointURL(url, port = undefined){\n    var portNumber;\n    if(port){\n      portNumber = port;\n    }\n    else if(state.currentNetworkProfile.httpPort){\n      portNumber = state.currentNetworkProfile.httpPort;\n    }\n    return location.protocol=='https:' ? `https://${url}` : `http://${url}:${portNumber}`;\n  }\n\n  buildWSEndpointURL(url, port = undefined){\n\n    var portNumber;\n    if(port){\n      portNumber = port;\n    }\n    else if(state.currentNetworkProfile.httpPort){\n      portNumber = state.currentNetworkProfile.httpPort;\n    }\n    return location.protocol=='https:' ? `wss://${url}` : `ws://${url}:${portNumber}`;\n  }\n\n  updateBlockHeight(blockInfo){\n    let blockHeight = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"UInt64\"]([blockInfo.height.lower, blockInfo.height.higher]).compact()\n    state.blockHeight = blockHeight;\n  }\n\n  updateChainNode(apiNode){\n    var chainProfilePreferences = new _storeClasses__WEBPACK_IMPORTED_MODULE_2__[\"ChainProfilePreferences\"]( state.chainNetworkName + \"_preferences\");\n    chainProfilePreferences.apiNode = apiNode;\n    chainProfilePreferences.saveToLocalStorage();\n    state.selectedChainNode = apiNode;\n    sessionStorage.setItem('selectedChainNode', state.selectedChainNode);\n    // this.dashboardService.destroySubscription();\n    // this.dataBridgeService.reconnect();\n    // this.nemProvider.validaTransactionsSwap();\n    // const address: Address[] = [];\n    // for (let account of this.walletService.currentWallet.accounts) {\n    //   address.push(this.proximaxProvider.createFromRawAddress(account.address));\n    // }\n\n    // this.mosaicService.getMosaicXPX();\n    // this.namespaces.searchNamespacesFromAccounts(address);\n    // this.transactionService.searchAccountsInfo(this.walletService.currentWallet.accounts);\n    // this.dataBridgeService.searchBlockInfo();\n    // this.dataBridgeService.searchBlockInfo(true);\n  }\n}\n\nconst chainNetworkInstance = new ChainNetwork();\nconst chainNetwork = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])(chainNetworkInstance);\n\n//# sourceURL=webpack:///./src/store/sirius.js?");

/***/ }),

/***/ "./src/store/storeClasses.js":
/*!***********************************!*\
  !*** ./src/store/storeClasses.js ***!
  \***********************************/
/*! exports provided: ChainProfile, Network, Currency, ChainExplorer, ChainProfileConfig, ChainProfileNames, ChainProfilePreferences */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainProfile\", function() { return ChainProfile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Network\", function() { return Network; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Currency\", function() { return Currency; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainExplorer\", function() { return ChainExplorer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainProfileConfig\", function() { return ChainProfileConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainProfileNames\", function() { return ChainProfileNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChainProfilePreferences\", function() { return ChainProfilePreferences; });\nconst walletKey = 'sw';\n\nclass StoreProperties{\n\n    constructor(storeName){\n        this.storeName = storeName;\n    }\n\n    init() {\n        let stateFromLocalStorage = localStorage.getItem(this.storeName);\n\n        if (stateFromLocalStorage) {\n                if(typeof stateFromLocalStorage === 'string' || stateFromLocalStorage instanceof String){\n                    Object.assign(this, JSON.parse(stateFromLocalStorage));\n                }\n                else{\n                    Object.assign(this, stateFromLocalStorage);\n                }\n        }\n    }\n\n    saveToLocalStorage(){\n        const stateCopy = Object.assign({}, this);\n        delete stateCopy.storeName;\n        localStorage.setItem(this.storeName, JSON.stringify(stateCopy));\n    }\n}\n\nclass ChainProfile extends StoreProperties{\n\n    constructor(storeName){\n        super(storeName);\n        this.version = '0.0.0';\n        this.apiNodes = [];\n        this.httpPort = 3000;\n        this.generationHash = \"\";\n        this.network = new Network();\n        this.chainExplorer = new ChainExplorer();\n    }\n\n    getVersion(){\n        return this.version;\n    }\n\n    serialize(){\n        return {\n            version: this.version,\n            apiNodes: this.apiNodes,\n            httpPort: this.httpPort,\n            generationHash: this.generationHash,\n            network: this.network.serialize(),\n            chainExplorer: this.chainExplorer.serialize()\n        };\n    }\n}\n\nclass Network{\n\n    constructor(){\n        this.type = 168;\n        this.currency = new Currency();\n    }\n\n    serialize(){\n        return {\n            type: this.type,\n            currency: this.currency.serialize()\n        };\n    }\n}\n\nclass Currency{\n\n    constructor(){\n        this.name = \"XPX\";\n        this.namespace = \"prx.xpx\";\n        this.mosaicId = \"\";\n        this.namespaceId = \"bffb42a19116bdf6\";\n        this.divisibility = 6;\n    }\n\n    serialize(){\n        return {\n            name: this.name,\n            namespace: this.namespace,\n            mosaicId: this.mosaicId,\n            namespaceId: this.namespaceId,\n            divisibility: this.divisibility\n        };\n    }\n}\n\nclass ChainExplorer{\n\n    constructor(){\n        this.url = \"https://bctestnetexplorer.xpxsirius.io\";\n        this.blockRoute = \"#/result/blockHeight\";\n        this.publicKeyRoute = \"#/result/publicKey\";\n        this.addressRoute = \"#/result/address\";\n        this.hashRoute = \"#/result/hash\";\n        this.namespaceInfoRoute = \"#/result/namespaceInfo\";\n        this.assetInfoRoute = \"#/result/assetInfo\";\n    }\n\n    serialize(){\n        return {\n            url: this.url,\n            blockRoute: this.blockRoute,\n            publicKeyRoute: this.publicKeyRoute,\n            addressRoute: this.addressRoute,\n            hashRoute: this.hashRoute,\n            namespaceInfoRoute: this.namespaceInfoRoute,\n            assetInfoRoute: this.assetInfoRoute\n        };\n    }\n}\n\nclass ChainProfileConfig extends StoreProperties {\n    constructor(storeName){\n        super(storeName);\n        this.chainHeight = null;\n        this.publicKey = '';\n        this.blockGenerationTargetTime = '';\n        this.blockTimeSmoothingFactor = null;\n        this.greedDelta = null;\n        this.greedExponent = null;\n        this.importanceGrouping = null;\n        this.maxRollbackBlocks = null;\n        this.maxDifficultyBlocks = null;\n        this.maxTransactionLifetime = '';\n        this.maxBlockFutureTime = '';\n        this.maxMosaicAtomicUnits = null;\n        this.totalChainImportance = null;\n        this.minHarvesterBalance = null;\n        this.harvestBeneficiaryPercentage = null;\n        this.blockPruneInterval = null;\n        this.maxTransactionsPerBlock = null;\n        this.maxTransactionsPerAggregate = null;\n        this.maxCosignaturesPerAggregate = null;\n        this.enableStrictCosignatureCheck = null; // boolean\n        this.enableBondedAggregateSupport = null; // boolean\n        this.maxBondedTransactionLifetime = '';\n        this.maxBlockChainConfigSize = '';\n        this.maxSupportedEntityVersionsSize = '';\n        this.minPercentageOfApproval = null;\n        this.minPercentageOfRemoval = null;\n        this.maxOfferDuration = null;\n        this.longOfferKey = '';\n        this.lockedFundsPerAggregate = null;\n        this.maxHashLockDuration = '';\n        this.maxSecretLockDuration = '';\n        this.minProofSize = null;\n        this.maxProofSize = null;\n        this.maxFields = null;\n        this.maxFieldKeySize = null;\n        this.maxFieldValueSize = null;\n        this.maxMosaicsPerAccount = null;\n        this.maxMosaicDuration = '';\n        this.maxMosaicDivisibility = null;\n        this.mosaicRentalFeeSinkPublicKey = '';\n        this.mosaicRentalFee = null;\n        this.maxMultisigDepth = null;\n        this.maxCosignersPerAccount = null;\n        this.maxCosignedAccountsPerAccount = null;\n        this.newCosignersMustApprove = null; // boolean\n        this.maxNameSize = null;\n        this.maxNamespaceDuration = '';\n        this.namespaceGracePeriodDuration = '';\n        this.reservedRootNamespaceNames = '';\n        this.namespaceRentalFeeSinkPublicKey = '';\n        this.rootNamespaceRentalFeePerBlock = null;\n        this.childNamespaceRentalFee = null;\n        this.maxChildNamespaces = null;\n        this.maxOperationDuration = '';\n        this.maxPropertyValues = null;\n        this.maxMessageSize = null;\n        this.maxMosaicsSize = null;\n        this.minUpgradePeriod = null;\n        this.maxFilesOnDrive = null;\n        this.verificationFee = null;\n        this.verificationDuration = null;\n        this.downloadDuration = null;\n        this.downloadCacheEnabled  = null; // boolean\n        this.maxSuperContractsOnDrive = null\n    }\n\n    updateConfig(config){\n        Object.assign(this, config);\n    }\n}\n\nclass ChainProfileNames extends StoreProperties {\n    constructor(storeName){\n        super(storeName);\n        this.names = [];\n    }\n\n    static createDefault(){\n        var newObj = new ChainProfileNames(\"ChainProfilesName\");\n        newObj.init();\n        return newObj;\n    }\n\n    replaceFirst2Names(names) {\n\n        var count = 0;\n\n        for(var i = 0; i < 2; i++){\n            var updated = this.replaceAndUpdateWallet(this.names[i], names[i], i);\n\n            count += updated ? 1 : 0;\n        }\n\n       return count;\n    }\n\n    replaceFirst3Names(names) {\n\n        var count = 0;\n\n        for(var i = 0; i < 3; i++){\n            var updated = this.replaceAndUpdateWallet(this.names[i], names[i], i);\n\n            count += updated ? 1 : 0;\n        }\n\n        return count;\n    }\n\n    replaceAndUpdateWallet(oldName, newName, index){\n        if(oldName !== newName){\n            var allWallets = JSON.parse(localStorage.getItem(walletKey));\n            var newWallets = [];\n\n            if(allWallets){\n                newWallets = allWallets.map((wallet)=>{\n                    if(wallet.networkName === oldName){\n                        wallet.networkName = newName;\n                    }\n                    \n                    return wallet;\n                });\n            }\n\n            localStorage.setItem(walletKey, JSON.stringify(newWallets));\n\n            this.names[index] = newName;\n\n            return true;\n        }\n\n        return false;\n    }\n}\n\nclass ChainProfilePreferences extends StoreProperties {\n    constructor(storeName){\n        super(storeName);\n        this.apiNode = \"\";\n    }\n}\n\n//# sourceURL=webpack:///./src/store/storeClasses.js?");

/***/ }),

/***/ "./src/util/listener.js":
/*!******************************!*\
  !*** ./src/util/listener.js ***!
  \******************************/
/*! exports provided: transferEmitter, startListening, stopListening, addListenerstoAccount, announceAggregateBonded, announceLockfundAndWaitForConfirmation, modifyMultisigAnnounceLockfundAndWaitForConfirmation, modifyMultisigAnnounceAggregateBonded */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transferEmitter\", function() { return transferEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startListening\", function() { return startListening; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stopListening\", function() { return stopListening; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addListenerstoAccount\", function() { return addListenerstoAccount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"announceAggregateBonded\", function() { return announceAggregateBonded; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"announceLockfundAndWaitForConfirmation\", function() { return announceLockfundAndWaitForConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modifyMultisigAnnounceLockfundAndWaitForConfirmation\", function() { return modifyMultisigAnnounceLockfundAndWaitForConfirmation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modifyMultisigAnnounceAggregateBonded\", function() { return modifyMultisigAnnounceAggregateBonded; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mitt */ \"./node_modules/mitt/dist/mitt.es.js\");\n/* harmony import */ var _store_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/store/app */ \"./src/store/app.js\");\n/* harmony import */ var _store_sirius__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/store/sirius */ \"./src/store/sirius.js\");\n/* harmony import */ var _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/multiSignatory.js */ \"./src/util/multiSignatory.js\");\n/* harmony import */ var _util_transactions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/transactions.js */ \"./src/util/transactions.js\");\n\n\n\n\nconst transferEmitter = Object(mitt__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n\n\n\n\n\nconst connectorListen = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])({});\n\nconst state = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])({\n  connector: []\n});\n\nconst startListening = (accounts) => {\n  // console.log(location.protocol);\n  accounts.forEach((account) => {\n    let connect = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Listener\"](_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].buildWSEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.selectedChainNode), WebSocket);\n    state.connector.push({listener: connect, account: account});\n    state.connector.find((element) => element.account.address == account.address).listener.open().then(() => {\n      enableListeners(account, connect);\n    });\n  });\n  let connect_block = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Listener\"](_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].buildWSEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.selectedChainNode), WebSocket);\n  state.connector.push({listener: connect_block, type: 'Bridge'});\n  state.connector.find((element) => element.type === 'Bridge').listener.open().then(() => {\n    newBlockListener(connect_block);\n  });\n}\n\n\nconst stopListening = () => {\n  // console.log('Connector length before stopping: ' + state.connector.length);\n  state.connector.forEach((connect) => {\n    // console.log(connect)\n    // console.log('Is connector listening: ' + connect.listener.isOpen());\n    if(connect.listener.isOpen()){\n      connect.listener.close();\n      connect.listener.terminate();\n    }\n  });\n  state.connector = [];\n\n  connectorListen.value = {};\n}\n\n// add listener to single account\nconst addListenerstoAccount = (account) => {\n  let connect = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Listener\"](_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].buildWSEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].state.selectedChainNode), WebSocket);\n  state.connector.push({listener: connect, account: account});\n  state.connector.find((element) => (element.account != undefined)?(element.account.address == account.address):'').listener.open().then(() => {\n    enableListeners(account, connect);\n  });\n}\n\nconst checkListener = () => {\n  state.connector.forEach((connect) => {\n    if(!connect.listener.isOpen()){\n      connect.listener.open();\n    }\n  });\n}\n\nsetInterval(() => {\n  // console.log('Num of connectors: ' + state.connector.length);\n  if(state.connector.length > 0){\n    // console.log('Checking connection every 10 sec');\n    checkListener();\n  }\n}, 10000);\n\n\nfunction enableListeners(account, listener){\n  // console.log('Connector for ' + account.address + ': ' + listener.isOpen());\n  const accountDetail = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromPublicKey(account.publicAccount.publicKey, account.network);\n  confirmedListener(accountDetail, listener);\n  unconfirmedListener(accountDetail, listener);\n  statusListener(accountDetail, listener);\n  unconfirmedRemovedListener(accountDetail, listener);\n  aggregateBondedAddedListener(accountDetail, listener);\n  aggregateBondedRemovedListener(accountDetail, listener);\n  cosignatureAddedListener(accountDetail, listener);\n}\n\n// subscribe new block\n// eslint-disable-next-line no-unused-vars\nconst newBlockListener = (listener) => {\n  // console.log(listener);\n  // eslint-disable-next-line no-unused-vars\n  listener.newBlock().subscribe(blockInfo => {\n    _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"chainNetwork\"].updateBlockHeight(blockInfo);\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// transaction confirmed\nconst confirmedListener = (accountDetail, listener) => {\n  listener.confirmed(accountDetail).subscribe((transaction) => {\n    console.log('Confirmed notification ' + accountDetail.address)\n    const wallet = _store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name);\n    // console.log(transaction)\n    transferEmitter.emit('CONFIRMED_NOTIFICATION', {\n      status: true,\n      message: 'Transaction confirmed',\n      notificationType: 'noti'\n    });\n    // check to list multisig account\n    if(_util_transactions_js__WEBPACK_IMPORTED_MODULE_6__[\"transactions\"].getNameTypeTransaction(transaction.type) == 'aggregateBonded'){\n      let cosigneeCheck = false;\n      transaction.cosignatures.forEach((cosignee) => {\n        console.log( 'cosignee.signer.address.address: ' + cosignee.signer.address.address);\n        const account = wallet.accounts.find((element) => element.address == cosignee.signer.address.address);\n        console.log('account');\n        console.log(account);\n        if(account){\n          cosigneeCheck = true;\n        }\n      });\n      if(cosigneeCheck){\n        transaction.innerTransactions.forEach((innerTran) => {\n          console.log( 'InnerTran: ' + _util_transactions_js__WEBPACK_IMPORTED_MODULE_6__[\"transactions\"].getNameTypeTransaction(innerTran.type))\n          if(_util_transactions_js__WEBPACK_IMPORTED_MODULE_6__[\"transactions\"].getNameTypeTransaction(innerTran.type) == 'modifyMultisigAccount'){\n            // create multisig account\n            // console.log('List multisign account into wallet');\n            console.log(innerTran.signer.publicKey, innerTran.signer.address.address)\n            // multiSign.createNewMultiSigAccount(innerTran.signer);\n            _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_5__[\"multiSign\"].createNewMultiSigAccount(innerTran.signer.publicKey, innerTran.signer.address.address);\n            // update multisign info on all accounts\n            // multiSign.updateAccountsMultiSign(appStore.state.currentLoggedInWallet.name);\n          }\n        });\n      }\n    }\n    transferEmitter.emit('UPDATE_DASHBOARD', {\n      status: true,\n      from: 'confirmed',\n      // transaction: Object.assign({}, transaction),\n      transaction: transaction,\n    });\n    _store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].updateXPXBalance(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"]);\n    // update multisign info on all accounts\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_5__[\"multiSign\"].updateAccountsMultiSign(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name);\n    // clean wallet from removed multisig account of cosigners\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_5__[\"multiSign\"].removeUnrelatedMultiSig(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name);\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// transaction unconfirmed\n// eslint-disable-next-line no-unused-vars\nconst unconfirmedListener = (accountDetail, listener) => {\n  listener.unconfirmedAdded(accountDetail).subscribe((transaction) => {\n    console.log('Unconfirmed notification ' + accountDetail.address);\n    if(_util_transactions_js__WEBPACK_IMPORTED_MODULE_6__[\"transactions\"].getNameTypeTransaction(transaction.type) != 'aggregateBonded'){\n      transferEmitter.emit('UNCONFIRMED_NOTIFICATION', {\n        status: true,\n        message: 'Transaction unconfirmed',\n        notificationType: 'noti'\n      });\n      transferEmitter.emit('UPDATE_DASHBOARD', {\n        status: true,\n        from: 'unconfirmedAdded',\n        transaction: Object.assign({}, transaction),\n      });\n    }\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// subscribe status\n// eslint-disable-next-line no-unused-vars\nconst statusListener = (accountDetail, listener) => {\n  listener.status(accountDetail).subscribe(transactionStatusError => {\n    // console.log('status listener');\n    // console.log(transactionStatusError);\n    transferEmitter.emit('STATUS_NOTIFICATION', {\n      status: true,\n      message: transactionStatusError,\n      notificationType: 'noti'\n    });\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// Unconfirmed removed\n// eslint-disable-next-line no-unused-vars\nconst unconfirmedRemovedListener = (accountDetail, listener) => {\n  listener.unconfirmedRemoved(accountDetail).subscribe(hash => {\n    console.log('Unconfirmed removed: ' + hash + ' ' + accountDetail.address);\n    transferEmitter.emit('UPDATE_DASHBOARD', {\n      status: true,\n      from: 'unconfirmedRemoved',\n      hash: hash,\n    });\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// partially added\n// eslint-disable-next-line no-unused-vars\nconst aggregateBondedAddedListener = (accountDetail, listener) => {\n  listener.aggregateBondedAdded(accountDetail).subscribe(aggregateTransaction => {\n    // console.log('Emitting from aggregateBondedAddedListener ');\n    // console.log(aggregateTransaction);\n    // choose btw aggregateBondedAdded to partialdatatable or unconfirmedAdded to dashboarddatatable\n    let innerTransactions = aggregateTransaction.innerTransactions;\n    let innerTransactionType, message;\n    innerTransactions.forEach( (innerTransaction) =>{\n      if(_util_transactions_js__WEBPACK_IMPORTED_MODULE_6__[\"transactions\"].getNameTypeTransaction(innerTransaction.type) == 'modifyMultisigAccount'){\n        innerTransactionType = 'aggregateBondedAdded';\n        message = 'Transaction aggregate bonded added';\n      }else{\n        innerTransactionType = 'unconfirmedAdded';\n        message = 'Transaction unconfirmed';\n      }\n    });\n    transferEmitter.emit('UNCONFIRMED_NOTIFICATION', {\n      status: true,\n      message: message,\n      notificationType: 'noti'\n    });\n    transferEmitter.emit('UPDATE_DASHBOARD', {\n      status: true,\n      from: innerTransactionType,\n      // transaction: Object.assign({}, aggregateTransaction),\n      transaction: aggregateTransaction,\n    });\n    _util_multiSignatory_js__WEBPACK_IMPORTED_MODULE_5__[\"multiSign\"].updateAccountsMultiSign(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name);\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// aggregate bonded removed\n// eslint-disable-next-line no-unused-vars\nconst aggregateBondedRemovedListener = (accountDetail, listener) => {\n  listener.aggregateBondedRemoved(accountDetail).subscribe(hash => {\n    console.log('Aggregate bonded removed: ' + hash + ' ' + accountDetail.address);\n    transferEmitter.emit('UPDATE_DASHBOARD', {\n      status: true,\n      from: 'aggregateBondedRemoved',\n      hash: hash,\n    });\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\n// eslint-disable-next-line no-unused-vars\nconst cosignatureAddedListener = (accountDetail, listener) => {\n  console.log('cosignatureAddedListener');\n  // eslint-disable-next-line no-unused-vars\n  listener.cosignatureAdded(accountDetail).subscribe(cosignatureSignedTransaction => {\n    transferEmitter.emit('UNCONFIRMED_NOTIFICATION', {\n      status: true,\n      message: 'Cosignature added',\n      notificationType: 'noti'\n    });\n    // update viewconvertaccountmultisig\n    transferEmitter.emit('ANNOUNCE_COSIGNITURE_ADDED', {\n      status: true,\n    });\n    transferEmitter.emit('UPDATE_DASHBOARD', {\n      status: true,\n      from: 'cosignatureAdded',\n      transaction: Object.assign({}, cosignatureSignedTransaction),\n    });\n  }, error => {\n      console.error(error);\n  }, () => {\n      console.log('done.');\n  })\n}\n\nasync function announceLockfundAndWaitForConfirmation(senderAddress, signedLockFundsTransaction, lockHash, transactionHttp){\n  return new Promise((resolve, reject) => {\n    const announceLockfundListener = _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].chainWSListener;\n    announceLockfundListener.open().then(() => {\n      const txStatus = announceLockfundListener.status(senderAddress).subscribe(txStatusError => {\n        if (txStatusError.hash === lockHash) {\n          console.error('Lockfund status (' + lockHash + ') error: ' + txStatusError.status);\n          if (txConfirmed) {\n            txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceLockfundListener.close();\n          reject(txStatusError.status);\n        }\n      });\n\n      const txConfirmed = announceLockfundListener.confirmed(senderAddress).subscribe(confirmedTx => {\n        if (confirmedTx && confirmedTx.transactionInfo && confirmedTx.transactionInfo.hash === lockHash) {\n          // console.log('Lockfund (' + lockHash + ') confirmed at height: ' + confirmedTx.transactionInfo.height.compact());\n          if (txConfirmed) {\n            txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceLockfundListener.close();\n          resolve(confirmedTx);\n        }\n      }, error => {\n        // console.error('Lockfund confirmation (' + lockHash + ') subscription failed: ' + error);\n        if (txConfirmed) {\n          txConfirmed.unsubscribe();\n        }\n        if (txStatus) {\n          txStatus.unsubscribe();\n        }\n        announceLockfundListener.close();\n        reject(error);\n      });\n\n      transactionHttp.announce(signedLockFundsTransaction).subscribe(\n          // eslint-disable-next-line no-unused-vars\n          (message)=>{\n              // console.log('Lockfund transaction (' + lockHash + ') announced');\n              transferEmitter.emit('CONFIRMED_NOTIFICATION', {\n                status: true,\n                message: 'Lockfund transaction announced',\n                notificationType: 'noti'\n              });\n              _store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].updateXPXBalance(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"]);\n          },\n          (error)=>{\n              console.log(error);\n              if (txConfirmed) {\n                  txConfirmed.unsubscribe();\n              }\n              if (txStatus) {\n                  txStatus.unsubscribe();\n              }\n              reject(error);\n          }\n      );\n\n    }).catch(reason => {\n      // console.error('Lockfund transaction (' + lockHash + ') listener exception caught: ' + reason);\n      announceLockfundListener.terminate();\n      reject(reason);\n    });\n  });\n}\n\nfunction announceAggregateBonded(senderAddress, aggBondTx, aggBondHash, txConfirmed, transactionHttp){\n  return new Promise((resolve, reject) => {\n    const announceAggregateBondedListener = _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"].chainWSListener;\n    announceAggregateBondedListener.open().then(() => {\n      const txStatus = announceAggregateBondedListener.status(senderAddress).subscribe(txStatusError => {\n        if (txStatusError.hash === aggBondHash) {\n          console.error('Aggregate status (' + aggBondHash + ') error: ' + txStatusError.status);\n          if (partialAdded) {\n            partialAdded.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceAggregateBondedListener.close();\n          reject(txStatusError.status);\n        }\n      });\n\n      const partialAdded = announceAggregateBondedListener.aggregateBondedAdded(senderAddress).subscribe(aggTransaction => {\n        if (aggTransaction && aggTransaction.transactionInfo && aggTransaction.transactionInfo.hash === aggBondHash) {\n          console.log('Aggregate bonded transaction (' + aggBondHash + ') added');\n          if (partialAdded) {\n            partialAdded.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceAggregateBondedListener.close();\n          resolve(aggTransaction);\n        }\n      }, error => {\n        // console.error('Aggregate bonded transaction (' + aggBondHash + ') subscription failed: ' + error);\n        if (partialAdded) {\n          partialAdded.unsubscribe();\n        }\n        if (txStatus) {\n          txStatus.unsubscribe();\n        }\n        announceAggregateBondedListener.close();\n        reject(error);\n      });\n\n      transactionHttp.announceAggregateBonded(aggBondTx).subscribe(\n        // eslint-disable-next-line no-unused-vars\n        (message)=>{\n          transferEmitter.emit('CONFIRMED_NOTIFICATION', {\n            status: true,\n            message: 'Aggregate transaction announced',\n            notificationType: 'noti'\n          });\n          transferEmitter.emit('ANNOUNCE_AGGREGATE_BONDED', {\n            status: true,\n          });\n          console.log('Aggregate transaction (' + aggBondHash + ') announced');\n        }, \n        (error)=>{\n          console.log(error);\n          if (txConfirmed) {\n              txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n              txStatus.unsubscribe();\n          }\n          reject(error);\n        }\n      );\n\n    }).catch(reason => {\n      // console.error('Aggregate bonded transaction (' + aggBondHash + ') listener exception caught: ' + reason);\n      announceAggregateBondedListener.terminate();\n      reject(reason);\n    });\n  });\n}\n\nasync function modifyMultisigAnnounceLockfundAndWaitForConfirmation(announceLockfundListener, senderAddress, signedLockFundsTransaction, lockHash, transactionHttp){\n  return new Promise((resolve, reject) => {\n    announceLockfundListener.open().then(() => {\n      const txStatus = announceLockfundListener.status(senderAddress).subscribe(txStatusError => {\n        if (txStatusError.hash === lockHash) {\n          console.error('Lockfund status (' + lockHash + ') error: ' + txStatusError.status);\n          if (txConfirmed) {\n            txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceLockfundListener.close();\n          reject(txStatusError.status);\n        }\n      });\n\n      const txConfirmed = announceLockfundListener.confirmed(senderAddress).subscribe(confirmedTx => {\n        if (confirmedTx && confirmedTx.transactionInfo && confirmedTx.transactionInfo.hash === lockHash) {\n          console.log('Lockfund (' + lockHash + ') confirmed at height: ' + confirmedTx.transactionInfo.height.compact());\n          if (txConfirmed) {\n            txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceLockfundListener.close();\n          resolve(confirmedTx);\n        }\n      }, error => {\n        console.error('Lockfund confirmation (' + lockHash + ') subscription failed: ' + error);\n        if (txConfirmed) {\n          txConfirmed.unsubscribe();\n        }\n        if (txStatus) {\n          txStatus.unsubscribe();\n        }\n        announceLockfundListener.close();\n        reject(error);\n      });\n\n      transactionHttp.announce(signedLockFundsTransaction).subscribe(\n          // eslint-disable-next-line no-unused-vars\n          (message)=>{\n              console.log('Lockfund transaction (' + lockHash + ') announced');\n              transferEmitter.emit('CONFIRMED_NOTIFICATION', {\n                status: true,\n                message: 'Lockfund transaction announced',\n                notificationType: 'noti'\n              });\n              _store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].updateXPXBalance(_store_app__WEBPACK_IMPORTED_MODULE_3__[\"appStore\"].state.currentLoggedInWallet.name, _store_sirius__WEBPACK_IMPORTED_MODULE_4__[\"siriusStore\"]);\n          },\n          (error)=>{\n              console.log(error);\n              if (txConfirmed) {\n                  txConfirmed.unsubscribe();\n              }\n              if (txStatus) {\n                  txStatus.unsubscribe();\n              }\n              reject(error);\n          }\n      );\n\n    }).catch(reason => {\n      // console.error('Lockfund transaction (' + lockHash + ') listener exception caught: ' + reason);\n      announceLockfundListener.terminate();\n      reject(reason);\n    });\n  });\n}\n\nfunction modifyMultisigAnnounceAggregateBonded(announceAggregateBondedListener, senderAddress, aggBondTx, aggBondHash, txConfirmed, transactionHttp){\n  return new Promise((resolve, reject) => {\n    announceAggregateBondedListener.open().then(() => {\n      const txStatus = announceAggregateBondedListener.status(senderAddress).subscribe(txStatusError => {\n        if (txStatusError.hash === aggBondHash) {\n          console.error('Aggregate status (' + aggBondHash + ') error: ' + txStatusError.status);\n          if (partialAdded) {\n            partialAdded.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceAggregateBondedListener.close();\n          reject(txStatusError.status);\n        }\n      });\n\n      const partialAdded = announceAggregateBondedListener.aggregateBondedAdded(senderAddress).subscribe(aggTransaction => {\n        if (aggTransaction && aggTransaction.transactionInfo && aggTransaction.transactionInfo.hash === aggBondHash) {\n          // console.log('Aggregate bonded transaction (' + aggBondHash + ') added');\n          if (partialAdded) {\n            partialAdded.unsubscribe();\n          }\n          if (txStatus) {\n            txStatus.unsubscribe();\n          }\n          announceAggregateBondedListener.close();\n          resolve(aggTransaction);\n        }\n      }, error => {\n        // console.error('Aggregate bonded transaction (' + aggBondHash + ') subscription failed: ' + error);\n        if (partialAdded) {\n          partialAdded.unsubscribe();\n        }\n        if (txStatus) {\n          txStatus.unsubscribe();\n        }\n        announceAggregateBondedListener.close();\n        reject(error);\n      });\n\n      transactionHttp.announceAggregateBonded(aggBondTx).subscribe(\n        // eslint-disable-next-line no-unused-vars\n        (message)=>{\n          transferEmitter.emit('CONFIRMED_NOTIFICATION', {\n            status: true,\n            message: 'Aggregate transaction announced',\n            notificationType: 'noti'\n          });\n          transferEmitter.emit('ANNOUNCE_AGGREGATE_BONDED', {\n            status: true,\n          });\n          // console.log('Aggregate transaction (' + aggBondHash + ') announced');\n        }, \n        (error)=>{\n          console.log(error);\n          if (txConfirmed) {\n              txConfirmed.unsubscribe();\n          }\n          if (txStatus) {\n              txStatus.unsubscribe();\n          }\n          reject(error);\n        }\n      );\n\n    }).catch(reason => {\n      // console.error('Aggregate bonded transaction (' + aggBondHash + ') listener exception caught: ' + reason);\n      announceAggregateBondedListener.terminate();\n      reject(reason);\n    });\n  });\n}\n\n\n\n//# sourceURL=webpack:///./src/util/listener.js?");

/***/ }),

/***/ "./src/util/multiSignatory.js":
/*!************************************!*\
  !*** ./src/util/multiSignatory.js ***!
  \************************************/
/*! exports provided: multiSign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiSign\", function() { return multiSign; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _store_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/store/app */ \"./src/store/app.js\");\n/* harmony import */ var _store_sirius__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/store/sirius */ \"./src/store/sirius.js\");\n/* harmony import */ var _util_listener_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/listener.js */ \"./src/util/listener.js\");\n\n\n\n// import { environment } from '../environment/environment.js';\n\n\n // chainNetwork\n\nconst walletKey = \"sw\";\n\nfunction verifyContactPublicKey(add, accountHttp){\n  const invalidPublicKey = '0000000000000000000000000000000000000000000000000000000000000000';\n  let address;\n  address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(add.toLocaleUpperCase());\n  return new Promise((resolve) => {\n    const accountInfo = accountHttp.getAccountInfo(address);\n    accountInfo.subscribe(\n      (account) => {\n        if (account.publicKey == invalidPublicKey) {\n          console.warn(`The receiver's public key is not valid for sending encrypted messages`);\n          resolve({status: false});\n        }else{\n          let payload = { status: true, publicKey: account.publicKey };\n          resolve(payload);\n        }\n      },\n      (error) => {\n        console.warn('Err: ' + error);\n        resolve(true);\n      }\n    );\n  });\n}\n\nfunction generateContact(selected){\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n  var contact = [];\n  wallet.accounts.forEach((element) => {\n    if(selected.indexOf(element.address) < 0){\n      contact.push({\n        value: element.address,\n        label: element.name + ' - Owner account',\n      });\n    }\n  });\n  if(wallet.contacts != undefined){\n    wallet.contacts.forEach((element) => {\n      if(selected.indexOf(element.address) < 0){\n        contact.push({\n          value: element.address,\n          label: element.name + ' - Contact',\n        });\n      }\n    });\n  }\n  return contact;\n}\n\nconst getPublicKey = (address) => {\n  return new Promise((resolve, reject) => {\n    _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].accountHttp.getAccountInfo(address).subscribe(accountInfo => {\n      resolve(accountInfo.publicKey);\n    }, error => {\n      reject('invalid');\n      console.error(error);\n    }, () => {\n        console.log('done.');\n    });\n  });\n}\n\n/* coSign: array() */\nfunction convertAccount(coSign, numApproveTransaction, numDeleteUser, accountToConvertName, walletPassword){\n\n  let verify = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].verifyWalletPassword(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name, walletPassword);\n  if(verify < 1){\n    return verify;\n  }\n\n  const add = fetch(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"]._buildAPIEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].state.selectedChainNode) + '/block/1').then((res) => res.json()).then((data) => { return data.meta.generationHash });\n\n  return add.then( async (generationHash) => {\n    const multisigCosignatory = [];\n    // console.log('Account to convert name: ' + accountToConvertName);\n    const accountDetails = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetails(accountToConvertName);\n\n    const networkType = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccountByWallet(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name).network;\n    let privateKey = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].decryptPrivateKey(walletPassword, accountDetails.encrypted, accountDetails.iv);\n    const accountToConvert = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(privateKey, networkType);\n\n    const cosignatory = [];\n    coSign.forEach( async (cosignKey, index) => {\n      if(cosignKey.length == 64){\n        cosignatory[index] = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(cosignKey, networkType);\n      }else if(cosignKey.length == 40 || cosignKey.length == 46){\n        let address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(cosignKey);\n\n        try {\n          let publicKey;\n          publicKey = await getPublicKey(address);\n          cosignatory[index] = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(publicKey, networkType);\n        } catch (error) {\n          console.log(error);\n        }\n      }\n\n      multisigCosignatory.push(new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModification\"](\n        tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModificationType\"].Add,\n        cosignatory[index],\n      ));\n    });\n\n    const convertIntoMultisigTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ModifyMultisigAccountTransaction\"].create(\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n      numApproveTransaction,\n      numDeleteUser,\n      multisigCosignatory,\n      networkType\n    );\n\n    const aggregateTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"AggregateTransaction\"].createBonded(\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n      [convertIntoMultisigTransaction.toAggregate(accountToConvert.publicAccount)],\n      networkType\n    );\n\n    const signedAggregateBoundedTransaction = accountToConvert.sign(aggregateTransaction, generationHash);\n\n    const lockFundsTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"LockFundsTransaction\"].create(\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NetworkCurrencyMosaic\"].createRelative(10),\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"UInt64\"].fromUint(1000),\n      signedAggregateBoundedTransaction,\n      networkType\n    );\n\n    const lockFundsTransactionSigned = accountToConvert.sign(lockFundsTransaction, generationHash);\n\n    const transactionHttp = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionHttp\"](_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"]._buildAPIEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].state.selectedChainNode));\n    (async ()=>{\n      try {\n          const confirmedTx = await Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_4__[\"announceLockfundAndWaitForConfirmation\"])(accountToConvert.address, lockFundsTransactionSigned, lockFundsTransactionSigned.hash, transactionHttp);\n          console.log('confirmedTx');\n          console.log(confirmedTx);\n          // eslint-disable-next-line no-unused-vars\n          var aggregateTx = await Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_4__[\"announceAggregateBonded\"])(accountToConvert.address, signedAggregateBoundedTransaction, signedAggregateBoundedTransaction.hash, confirmedTx, transactionHttp )\n          console.log('aggregateTx');\n          console.log(aggregateTx);\n          console.log(\"Done\");\n      } catch (error) {\n          console.log(error);\n      }\n    })();\n  });\n}\n\nfunction getAggregateBondedTransactions(publicAccount) {\n  return _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].accountHttp.aggregateBondedTransactions(publicAccount, new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"QueryParams\"](100));\n}\n\nfunction onPartial(publicAccount){\n  return new Promise((resolve) => {\n    getAggregateBondedTransactions(publicAccount).subscribe((txOnpartial) => {\n      let isPartial = false;\n      if (txOnpartial !== null && txOnpartial.length > 0) {\n        for (const tx of txOnpartial) {\n          for (let i = 0; i < tx.innerTransactions.length; i++) {\n            isPartial = (tx.innerTransactions[i].signer.publicKey === publicAccount.publicKey);\n            if (isPartial) {\n              break;\n            }\n          }\n          if (isPartial) {\n            break;\n          }\n        }\n      }\n      resolve(isPartial);\n    });\n  });\n}\n\nfunction multisigAccountInfo(address) {\n  return _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].accountHttp.getMultisigAccountInfo(address);\n}\n\nfunction getMultisigAccountGraphInfo(address) {\n  return _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].accountHttp.getMultisigAccountGraphInfo(address);\n}\n\nfunction updateAccountMultisigGraphInfo(accountAddress){\n  return new Promise((resolve) => {\n    const address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(accountAddress);\n    getMultisigAccountGraphInfo(address).subscribe(info => {\n      const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n      const account = wallet.accounts.find((element) => element.address == accountAddress);\n      const multigraph = [];\n      // console.log('info.multisigAccounts');\n      // console.log(accountAddress + ' ' + account.name);\n      // console.log(info.multisigAccounts);\n      info.multisigAccounts.forEach(( multi ) => {\n        // console.log(multi);\n        multi.forEach((m) =>{\n          // console.log(m)\n          // console.log(m.address)\n          multigraph.push(m);\n        })\n      });\n      account.multisigAccountGraphInfo = multigraph;\n      resolve(info);\n      try {\n        sessionStorage.setItem(\n          'currentWalletSession',\n          JSON.stringify(wallet)\n        );\n        localStorage.setItem(\n          walletKey,\n          JSON.stringify(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.wallets)\n        );\n      } catch (err) {\n        console.error(\"checkIsMultiSig error caught\", err);\n      }\n    }, error => {\n      console.log(error);\n    });\n  });\n}\n\nfunction checkIsMultiSig(accountAddress){\n  return new Promise((resolve) => {\n    const address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(accountAddress);\n    multisigAccountInfo(address).subscribe(info => {\n      const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n      const account = wallet.accounts.find((element) => element.address == accountAddress);\n      account.isMultisign = info;\n      let verify = false;\n      if(account.isMultisign != '' || account.isMultisign != null){\n        if(account.isMultisign.cosignatories != undefined){\n          if(account.isMultisign.cosignatories.length > 0){\n            verify = true;\n          }\n        }\n      }\n      resolve(verify);\n      try {\n        sessionStorage.setItem(\n          'currentWalletSession',\n          JSON.stringify(wallet)\n        );\n        localStorage.setItem(\n          walletKey,\n          JSON.stringify(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.wallets)\n        );\n      } catch (err) {\n        console.error(\"checkIsMultiSig error caught\", err);\n      }\n      // eslint-disable-next-line no-unused-vars\n    }, error => {\n      resolve(false);\n    });\n  });\n}\n\nfunction updateAccountsMultiSign(walletName){\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(walletName);\n  wallet.accounts.forEach( async (element) => {\n    try {\n      await checkIsMultiSig(element.address);\n      await updateAccountMultisigGraphInfo(element.address);\n    } catch (err) {\n      console.log(err);\n      console.error(\"updateAccountsMultiSign error caught\", err);\n    }\n  });\n  return 'invalid_wallet';\n}\n\nfunction createMultiSigAccount(walletName){\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(walletName);\n  wallet.accounts.forEach( (element) => {\n    if(element.isMultisign){\n      if(element.isMultisign.cosignatories.length == 0){\n        console.log(element.address)\n        element.isMultisign.multisigAccounts.forEach((multisig) => {\n          let multisigStatus = wallet.accounts.find((element) => element.address === multisig.address.address);\n          if(!multisigStatus){\n            console.log(multisig)\n            _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].updateCreatedMultiSigToWallet(multisig.publicKey, multisig.address.address);\n          }\n        });\n        updateAccountsMultiSign(walletName);\n        // get latest xpx amount\n        _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getXPXBalance(walletName, _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"]).then(()=> {\n          _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].updateWalletConfig(wallet);\n        });\n      }\n    }\n  });\n}\n\nconst removeUnrelatedMultiSig = (walletName) => {\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(walletName);\n  let multiSigAccounts = wallet.accounts.filter((element) => element.encrypted === undefined);\n  let removeMultiSig = [];\n  multiSigAccounts.forEach( (element) => {\n    let validMultiSig = false;\n    if(element.isMultisign){\n      element.isMultisign.cosignatories.forEach((account) => {\n        if(wallet.accounts.find(element => element.address == account.address.address)){\n          validMultiSig = true;\n        }\n      });\n    }\n    if(!validMultiSig){\n      removeMultiSig.push(element.address);\n    }\n  });\n  // remove multisig account\n  _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].removeMultiSigAccount(removeMultiSig);\n};\n\nconst cosignMiltisigTransaction = (signedAggregateBoundedTransaction, walletPassword) => {\n  // console.log('signedAggregateBoundedTransaction')\n  // console.log(signedAggregateBoundedTransaction)\n  let coSignAddress = signedAggregateBoundedTransaction.account;\n  // console.log('co: ' + coSignAddress)\n  const accountDetails = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(coSignAddress);\n  const networkType = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccountByWallet(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name).network;\n  let privateKey = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].decryptPrivateKey(walletPassword, accountDetails.encrypted, accountDetails.iv);\n  const account = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(privateKey, networkType);\n\n  const cosignAggregateBondedTransaction = (signedAggregateBoundedTransaction, account) => {\n    const cosignatureTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"CosignatureTransaction\"].create(signedAggregateBoundedTransaction);\n    let signStatus = account.signCosignatureTransaction(cosignatureTransaction);\n    return signStatus;\n  };\n  _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].accountHttp.aggregateBondedTransactions(account.publicAccount).subscribe((transactions)=>{\n    console.log(transactions);\n    for(const aggregateTx of transactions){\n      // view transaction details...\n      let cosigned = aggregateTx.signedByAccount(account.publicAccount);\n      if(!cosigned && aggregateTx.transactionInfo.hash === signedAggregateBoundedTransaction.transactionInfo.hash){\n          let cosignatureSignedTransaction = cosignAggregateBondedTransaction(aggregateTx, account);\n          _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].transactionHttp.announceAggregateBondedCosignature(cosignatureSignedTransaction);\n      }\n    }\n  });\n};\n\nconst createNewMultiSigAccount = (publicKey, address) => {\n  // const networkType = appStore.getAccountByWallet(appStore.state.currentLoggedInWallet.name).network;\n  // check if multiSig is already in wallet\n  // console.log('publicAccount');\n  // console.log(publicAccount);\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n  let multiSig = wallet.accounts.find((element) => element.address === address);\n  if(!multiSig){\n    _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].updateCreatedMultiSigToWallet(publicKey, address);\n  }\n}\n\n// modify multisig\nfunction modifyMultisigAccount(coSign, removeCosign, numApproveTransaction, numDeleteUser, cosigners, multisigAccount, walletPassword){\n\n  let verify = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].verifyWalletPassword(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name, walletPassword);\n  if(verify < 1){\n    return verify;\n  }\n\n  const add = fetch(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"]._buildAPIEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].state.selectedChainNode) + '/block/1').then((res) => res.json()).then((data) => { return data.meta.generationHash });\n\n  return add.then( async (generationHash) => {\n    const multisigCosignatory = [];\n    let coSigner = [];\n    const networkType = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccountByWallet(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name).network;\n    if(cosigners.length > 0){\n      cosigners.forEach((signer) => {\n        const accountDetails = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(signer.address);\n        let privateKey = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].decryptPrivateKey(walletPassword, accountDetails.encrypted, accountDetails.iv);\n        coSigner.push(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Account\"].createFromPrivateKey(privateKey, networkType));\n      });\n    }\n\n    const cosignatory = [];\n    coSign.forEach( async (cosignKey, index) => {\n      if(cosignKey.length == 64){\n        cosignatory[index] = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(cosignKey, networkType);\n      }else if(cosignKey.length == 40 || cosignKey.length == 46){\n        // option to accept address\n        let address = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Address\"].createFromRawAddress(cosignKey);\n\n        try {\n          let publicKey;\n          publicKey = await getPublicKey(address);\n          cosignatory[index] = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(publicKey, networkType);\n        } catch (error) {\n          console.log(error);\n        }\n      }\n\n      multisigCosignatory.push(new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModification\"](\n        tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModificationType\"].Add,\n        cosignatory[index],\n      ));\n    });\n\n    removeCosign.forEach( (element, index) => {\n      cosignatory[coSign.length + index] = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(element, networkType);\n      multisigCosignatory.push(new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModification\"](\n        tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"MultisigCosignatoryModificationType\"].Remove,\n        cosignatory[coSign.length + index],\n      ));\n    });\n\n    let relativeNumApproveTransaction = numApproveTransaction - multisigAccount.isMultisign.minApproval;\n    let relativeNumDeleteUser = numDeleteUser - multisigAccount.isMultisign.minRemoval\n\n    const convertIntoMultisigTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"ModifyMultisigAccountTransaction\"].create(\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n      relativeNumApproveTransaction,\n      relativeNumDeleteUser,\n      multisigCosignatory,\n      networkType\n    );\n\n    const aggregateTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"AggregateTransaction\"].createBonded(\n      tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n      [convertIntoMultisigTransaction.toAggregate(multisigAccount.publicAccount)],\n      networkType\n    );\n\n    if(coSigner.length > 0){\n      let transactions = [];\n      coSigner.forEach((coSignerAccount) => {\n        const signedAggregateBoundedTransaction = coSignerAccount.sign(aggregateTransaction, generationHash);\n\n        const lockFundsTransaction = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"LockFundsTransaction\"].create(\n          tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].create(),\n          tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NetworkCurrencyMosaic\"].createRelative(10),\n          tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"UInt64\"].fromUint(1000),\n          signedAggregateBoundedTransaction,\n          networkType\n        );\n\n        const lockFundsTransactionSigned = coSignerAccount.sign(lockFundsTransaction, generationHash);\n\n        transactions.push({ coSignerAccount: coSignerAccount, signedAggregateBoundedTransaction: signedAggregateBoundedTransaction, lockFundsTransactionSigned: lockFundsTransactionSigned });\n      });\n\n      const transactionHttp = new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionHttp\"](_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"]._buildAPIEndpointURL(_store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].state.selectedChainNode));\n      (async ()=>{\n        try {\n          let lockFundListeners = [];\n          let aggregateBoundedListeners = [];\n          let confirmedTx = [];\n          let aggregateTx = [];\n          // transactions.forEach(async(transaction, item) =>{\n          let item = 0;\n          for (const transaction of transactions) {\n            lockFundListeners[item] = _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].chainWSListener;\n            confirmedTx[item] = await Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_4__[\"modifyMultisigAnnounceLockfundAndWaitForConfirmation\"])(lockFundListeners[item], transaction.coSignerAccount.address, transaction.lockFundsTransactionSigned, transaction.lockFundsTransactionSigned.hash, transactionHttp);\n            aggregateBoundedListeners[item] = _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].chainWSListener;\n            aggregateTx[item] = await Object(_util_listener_js__WEBPACK_IMPORTED_MODULE_4__[\"modifyMultisigAnnounceAggregateBonded\"])(aggregateBoundedListeners[item], transaction.coSignerAccount.address, transaction.signedAggregateBoundedTransaction, transaction.signedAggregateBoundedTransaction.hash, confirmedTx[item], transactionHttp );\n            ++item;\n          }\n        } catch (error) {\n            console.log(error);\n        }\n      })();\n    }\n  });\n}\n\nconst fetchMultiSigCosigners = (multiSigAddress) => {\n  const account = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(multiSigAddress);\n  if(account.isMultisign.cosignatories){\n    let list = [];\n    let numCosigner = account.isMultisign.cosignatories.length;\n    if(numCosigner > 0){\n      if( numCosigner > 1 ){\n        account.isMultisign.cosignatories.forEach((element) => {\n          let cosignAccount = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(element.address.address);\n          if(cosignAccount != -1){\n            list.push({ address: element.address.address, name: cosignAccount.name });\n          }\n        });\n      }else{\n        // console.log(account.isMultisign.cosignatories.length)\n        let cosignAccount = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(account.isMultisign.cosignatories[0].address.address);\n        if(cosignAccount != -1){\n          list.push({ address: account.isMultisign.cosignatories[0].address.address, name: cosignAccount.name });\n        }\n      }\n    }else{\n      list = [];\n    }\n    return { list: list, length: numCosigner };\n  }else{\n    return {\n      list: [],\n      length: 0\n    };\n  }\n}\n\nfunction fetchWalletCosigner(address){\n  let cosign = multiSign.fetchMultiSigCosigners(address);\n  let list = [];\n  cosign.list.forEach((element) => {\n    const account = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccDetailsByAddress(element.address);\n    list.push({ balance: account.balance, address: element.address, name: element.name });\n  });\n  list.sort((a, b) => (a.balance < b.balance) ? 1 : -1);\n  return { list:list, numCosigner: cosign.numCosigner };\n}\n\nconst multiSign = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])({\n  // config,\n  getPublicKey,\n  generateContact,\n  verifyContactPublicKey,\n  convertAccount,\n  onPartial,\n  checkIsMultiSig,\n  updateAccountsMultiSign,\n  cosignMiltisigTransaction,\n  createNewMultiSigAccount,\n  updateAccountMultisigGraphInfo,\n  getMultisigAccountGraphInfo,\n  modifyMultisigAccount,\n  fetchMultiSigCosigners,\n  fetchWalletCosigner,\n  removeUnrelatedMultiSig,\n  createMultiSigAccount,\n});\n\n\n//# sourceURL=webpack:///./src/util/multiSignatory.js?");

/***/ }),

/***/ "./src/util/namespaces.js":
/*!********************************!*\
  !*** ./src/util/namespaces.js ***!
  \********************************/
/*! exports provided: namespaces */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"namespaces\", function() { return namespaces; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _environment_environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../environment/environment.js */ \"./src/environment/environment.js\");\n/* harmony import */ var _store_sirius__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/store/sirius */ \"./src/store/sirius.js\");\n\n\n\n\n\nconst saveNamespaceStorage = async (namespaceInfo) => {\n  // console.log('\\n\\n\\n ----namespaceInfo----', namespaceInfo, '\\n\\n\\n');\n  const namespacesStorage = getNamespacesStorage();\n  const names = await _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].namespaceHttp.getNamespacesName(namespaceInfo.map(x => x.id)).toPromise();\n  console.log('----names---', names);\n  const namespacesFound = [];\n  for (const info of namespaceInfo) {\n    namespacesFound.push({\n      id: [info.id.id.lower, info.id.id.higher],\n      idToHex: info.id.toHex(),\n      namespaceName: names.find(name => name.namespaceId.toHex() === info.id.toHex()),\n      namespaceInfo: info\n    });\n  }\n\n  const namespaceToSaved = namespacesFound.slice(0);\n  if (namespacesStorage.length > 0 && namespaceToSaved.length > 0) {\n    for (const namespacesSaved of namespacesStorage) {\n      const existNamespace = namespaceToSaved.find(b => b.idToHex === namespacesSaved.idToHex);\n      // console.log('----existe?----', existNamespace);\n      if (!existNamespace) {\n        namespaceToSaved.push(namespacesSaved);\n      }\n    }\n  }\n\n  // console.log('-TODO LO QUE GUARDAR', namespaceToStorage);\n  localStorage.setItem(_environment_environment_js__WEBPACK_IMPORTED_MODULE_2__[\"environment\"].nameKeyNamespaces, JSON.stringify(namespaceToSaved));\n  undefined.fillNamespacesDefaultAccount();\n}\n\nconst getNamespacesStorage = () => {\n  const namespacesStorage = localStorage.getItem(_environment_environment_js__WEBPACK_IMPORTED_MODULE_2__[\"environment\"].nameKeyNamespaces);\n  return (namespacesStorage !== null && namespacesStorage !== undefined) ? JSON.parse(namespacesStorage) : [];\n}\n\nfunction getNamespace(namespace) {\n  return _store_sirius__WEBPACK_IMPORTED_MODULE_3__[\"siriusStore\"].namespaceHttp.getNamespace(namespace);\n}\n\nfunction getNamespaceId(id) {\n  return new tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"NamespaceId\"](id);\n}\n\nconst getNamespaceFromId = async (namespaceId, recursive = true) => {\n  const dataFound = [];\n  const missingId = [];\n  const namespacesStorage = getNamespacesStorage();\n  if (namespacesStorage.length > 0 && namespaceId.length > 0) {\n    for (const id of namespaceId) {\n      const x = namespacesStorage.find(next => next.idToHex === id.toHex());\n      if (x && Object.keys(x).length > 0) {\n        dataFound.push(x);\n      } else {\n        missingId.push(id);\n      }\n    }\n  } else {\n    namespaceId.forEach(id => {\n      missingId.push(id);\n    });\n  }\n\n  if (missingId.length > 0 && recursive) {\n    for (const id of missingId) {\n      try {\n        // Gets array of NamespaceInfo for an account\n        const namespaceInfo = await getNamespace(id).toPromise();\n        if (namespaceInfo && Object.keys(namespaceInfo).length > 0) {\n          await saveNamespaceStorage([namespaceInfo]);\n        }\n        // disable-next-line no-unused-vars\n      } catch (error) {\n        // console.log('----Search namespaces from accounts error----', error);\n      }\n    }\n    return getNamespaceFromId(namespaceId, false);\n  }\n\n  return dataFound;\n}\n\n\nconst namespaces = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])({\n  getNamespaceId,\n  getNamespaceFromId,\n});\n\n//# sourceURL=webpack:///./src/util/namespaces.js?");

/***/ }),

/***/ "./src/util/transactions.js":
/*!**********************************!*\
  !*** ./src/util/transactions.js ***!
  \**********************************/
/*! exports provided: transactions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transactions\", function() { return transactions; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm-bundler.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tsjs-xpx-chain-sdk */ \"./node_modules/tsjs-xpx-chain-sdk/dist/index.js\");\n/* harmony import */ var tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _store_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/store/app */ \"./src/store/app.js\");\n/* harmony import */ var _util_namespaces_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/namespaces.js */ \"./src/util/namespaces.js\");\n/* harmony import */ var _environment_environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../environment/environment.js */ \"./src/environment/environment.js\");\n\n\n\n// import { proximaxProvider } from '../util/proximaxProvider.js';\n\n\n\n\n// let provider =  proximaxProvider;\n\nconst getNameTypeTransaction = (type) => {\n  return Object.keys(arraTypeTransaction).find(\n    elm => arraTypeTransaction[elm].id === type\n  );\n}\n\nconst arraTypeTransaction = {\n  transfer: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].TRANSFER,\n    name: 'Transfer'\n  },\n  registerNameSpace: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].REGISTER_NAMESPACE,\n    name: 'Register Namespace'\n  },\n  mosaicDefinition: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].MOSAIC_DEFINITION,\n    name: 'Mosaic Definition'\n  },\n  mosaicSupplyChange: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].MOSAIC_SUPPLY_CHANGE,\n    name: 'Mosaic Supply Change'\n  },\n  modifyMultisigAccount: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].MODIFY_MULTISIG_ACCOUNT,\n    name: 'Modify Multisig Account'\n  },\n  aggregateComplete: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].AGGREGATE_COMPLETE,\n    name: 'Aggregate Complete'\n  },\n  aggregateBonded: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].AGGREGATE_BONDED,\n    name: 'Aggregate Bonded'\n  },\n  mosaicAlias: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].MOSAIC_ALIAS,\n    name: 'Mosaic Alias'\n  },\n  addressAlias: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].ADDRESS_ALIAS,\n    name: 'Address Alias'\n  },\n  lock: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].LOCK,\n    name: 'LockFund'\n  },\n  accountLink: {\n    id: tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"TransactionType\"].LINK_ACCOUNT,\n    name: 'Account Link'\n  }\n  /*secretLock: {\n    id: TransactionType.SECRET_LOCK,\n    name: \"Secret lock\"\n  },*/\n  /* secretProof: {\n    id: TransactionType.SECRET_PROOF,\n    name: \"Secret proof\"\n  }*/\n};\n\nconst formatTransaction = (transaction, names) => {\n  let keyName = getNameTypeTransaction(transaction.type);\n  transaction.typeName = arraTypeTransaction[keyName].name;\n  transaction.transferType = formatTransfer(transaction);\n  let senderName = names.find((element) =>  element.address == getSender(transaction));\n  transaction.senderName = (senderName)?senderName.name:'';\n  transaction.senderAddress = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].pretty(getSender(transaction));\n  let recipientAddress = getRecipient(transaction, keyName);\n  let recipientName = names.find((element) =>  element.address == recipientAddress);\n  transaction.recipientName = (recipientName)?recipientName.name:'';\n  if(recipientAddress.length >= 40){\n    transaction.recipientAddress = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].pretty(recipientAddress);\n  }\n  // transaction.recipientAddress = appStore.pretty(recipientAddress);\n  transaction.block = transaction.transactionInfo.height.compact();\n  transaction.data = transaction;\n  transaction.hash = transaction.transactionInfo.hash;\n  return transaction;\n}\n\nconst formatAggregateBondedTransaction = (transaction, names) => {\n  console.log(transaction);\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n\n  // 1st matching - check if signer is in the wallet\n  let signerInWallet = wallet.accounts.find((element) => element.address == transaction.signer.address.address);\n\n  if(signerInWallet){ // signer is in the wallet\n    // display own as signer\n    console.log('1st level')\n    let linkedAccountName = names.find((element) =>  element.address == signerInWallet.address);\n    transaction.linkedAccountName = (linkedAccountName)?linkedAccountName.name:'';\n    transaction.linkedAccount = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].pretty(signerInWallet.address);\n    transaction.account = transaction.linkedAccount;\n  }else{\n    // display first cosig\n    // bug fixed for innerTransactions\n    // 2nd matching - match innertransaction.modification.address to wallet's accounts or contact list\n    // search for own account among cosig\n    console.log('2nd level')\n    var matchAccount;\n    transaction.innerTransactions.forEach((inner) => {\n      if(inner.modifications != undefined){\n        inner.modifications.forEach((modification) => {\n          var matchStatus;\n          matchStatus = wallet.accounts.find((element) => element.address == modification.cosignatoryPublicAccount.address.address);\n          if(matchStatus){\n            matchAccount = matchStatus;\n          }\n        });\n      }\n    });\n    if(matchAccount){\n      transaction.account = matchAccount.address;\n      let linkedAccountName = names.find((element) =>  element.address == matchAccount.address);\n      transaction.linkedAccountName = (linkedAccountName)?linkedAccountName.name:'';\n      transaction.linkedAccount = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].pretty(matchAccount.address);\n    }else{\n      // 3rd matching - match among cosignatures in transaction\n      console.log('3rd level')\n      var isMatchAccount = false;\n      if(transaction.cosignatures.length > 0){\n        transaction.cosignatures.forEach((cosigner) => {\n          matchAccount = wallet.accounts.find((element) => element.address == cosigner.signer.address.address);\n          if(matchAccount){\n            transaction.account = matchAccount.address;\n            let linkedAccountName = names.find((element) =>  element.address == matchAccount.address);\n            transaction.linkedAccountName = (linkedAccountName)?linkedAccountName.name:'';\n            isMatchAccount = true;\n          }\n        });\n      }\n      if(!isMatchAccount){\n        console.log('4th level')\n        // 4th matching - search in multisign property in state\n        let cosigner = getAccountsInfoTiedMultiSig(transaction.innerTransactions[0].signer.publicKey);\n        // if there is more than 1 signer, temporarily assign the first one to be displayed in partial datatable\n        if(cosigner.length > 0){\n          // if(cosigner.length > 1){\n            transaction.account = cosigner[0].address;\n            let linkedAccountName = names.find((element) =>  element.address == cosigner[0].address);\n            transaction.linkedAccountName = (linkedAccountName)?linkedAccountName.name:'';\n          // }\n        }else{\n          transaction.account = '';\n        }\n      }\n    }\n  }\n\n  transaction.formattedDeadline = `${dateFormat(transaction.deadline)}`;\n  transaction.totalSigned = 0;\n  transaction.isSigned = false;\n  wallet.accounts.forEach(element => {\n    // const publicAccount = provider.createPublicAccount(element.publicAccount.publicKey);\n    let networkType = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getAccountByWallet(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name).network;\n    const publicAccount = tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"PublicAccount\"].createFromPublicKey(element.publicAccount.publicKey, networkType);\n    const x = transaction.signedByAccount(publicAccount);\n    if (x) {\n      transaction.totalSigned += 1;\n      transaction.isSigned = true;\n    }\n  });\n  transaction.hash = transaction.transactionInfo.hash;\n  return transaction;\n}\n\nconst getAccountsInfoTiedMultiSig = (signerPublicKey) => {\n  let cosigner = [];\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n  wallet.accounts.forEach(account => {\n    if(account.isMultisign != undefined){\n      if(account.isMultisign.multisigAccounts != undefined){\n        if(account.isMultisign.multisigAccounts.length > 0){\n          account.isMultisign.multisigAccounts.forEach(multisig => {\n            console.log(multisig.publicKey + ' ' + signerPublicKey)\n            if(multisig.publicKey == signerPublicKey){\n              cosigner.push({address: account.publicAccount.address.address});\n            }\n          });\n        }\n      }\n    }\n  });\n  return cosigner;\n};\n\nconst formatTransfer = (transaction) => {\n  const wallet = _store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].getWalletByName(_store_app__WEBPACK_IMPORTED_MODULE_2__[\"appStore\"].state.currentLoggedInWallet.name);\n  const sender = transaction.signer.address.address;\n  if(wallet.accounts.find((element) => element.address == sender)){\n    return 'out';\n    // return '/assets/img/arrow-transaction-sender-out-orange-proximax-sirius-explorer.4fb6ecda.svg';\n  }else{\n    return 'in';\n    // return '/assets/img/arrow-transaction-receive-in-green-proximax-sirius-explorer.9d5ca495.svg';\n  }\n}\n\nconst getSender = (transaction) => {\n  return transaction.signer.address.address;\n}\n\nconst getRecipient = (transaction, keyName) => {\n  let address;\n  switch(keyName){\n    case 'transfer':{\n      address = transaction.recipient.address;\n      break;\n    }\n    case 'aggregateBonded':{\n      if(transaction.innerTransactions[0].recipient != undefined){\n        address = transaction.innerTransactions[0].recipient.address;\n      }else{\n        address = '-';\n      }\n      break;\n    }\n    default:\n      address = '-';\n  }\n  return address;\n}\n\nconst dateFormat = (deadline) => {\n  return new Date(\n    deadline.value.toString() + tsjs_xpx_chain_sdk__WEBPACK_IMPORTED_MODULE_1__[\"Deadline\"].timestampNemesisBlock * 1000\n  ).toLocaleString();\n}\n\nconst dateFormatUTC = (date) => {\n  return new Date(date.compact() + 1459468800 * 1000).toLocaleString();\n}\n\nconst amountFormatterSimple = (amount, d = 6) => {\n  const amountDivisibility = Number(amount) / Math.pow(10, d);\n  return amountDivisibility.toLocaleString('en-us', {\n    minimumFractionDigits: d\n  });\n}\n\nconst getDataPart = (data, cantPart) => {\n  return {\n    part1: data.slice(0, data.length - cantPart),\n    part2: data.slice(-cantPart)\n  };\n}\n\nconst getAmount = async (id, transaction) => {\n  let d = 6;\n  const n = await _util_namespaces_js__WEBPACK_IMPORTED_MODULE_3__[\"namespaces\"].getNamespaceFromId([id]);\n  // eslint-disable-next-line no-unused-vars\n  let namespaceName = id.toHex();\n  if ((n.length > 0)) {\n    namespaceName = (n[0].namespaceName.name === 'prx.xpx') ? 'XPX' : n[0].namespaceName.name;\n    const x = _environment_environment_js__WEBPACK_IMPORTED_MODULE_4__[\"environment\"].swapAllowedMosaics.find(r => `${r.namespaceId}.${r.name}` === n[0].namespaceName.name);\n    if (x) { d = x.divisibility; }\n  }\n  const amount = amountFormatterSimple(transaction.mosaics[0].amount.compact(), d);\n  return getDataPart(amount.toString(), d);\n}\n\nconst getLockFundAmount = async (id, transaction) => {\n  let d = 6;\n  const n = await _util_namespaces_js__WEBPACK_IMPORTED_MODULE_3__[\"namespaces\"].getNamespaceFromId([id]);\n  // console.log('n: ' + n)\n  // eslint-disable-next-line no-unused-vars\n  let namespaceName = id.toHex();\n  // console.log('namespaceName')\n  // console.log(namespaceName)\n  if ((n.length > 0)) {\n    namespaceName = (n[0].namespaceName.name === 'prx.xpx') ? 'XPX' : n[0].namespaceName.name;\n    const x = _environment_environment_js__WEBPACK_IMPORTED_MODULE_4__[\"environment\"].swapAllowedMosaics.find(r => `${r.namespaceId}.${r.name}` === n[0].namespaceName.name);\n    if (x) { d = x.divisibility; }\n  }\n  const amount = amountFormatterSimple(transaction.mosaic.amount.compact(), d);\n  return getDataPart(amount.toString(), d);\n}\n\n\n/*\nfunction getTransactionData (transaction){\n  let timestamp, effectiveFee;\n  if (transaction.transactionInfo && transaction.transactionInfo.height) {\n    const height = transaction.transactionInfo.height.compact();\n    if (typeof (height) === 'number') {\n      const existBlock = dataBridge.filterBlockStorage(height);\n      console.log(existBlock)\n      if (existBlock) {\n        console.log('In cache', existBlock);\n        timestamp = `${dateFormatUTC(new UInt64([existBlock.timestamp.lower, existBlock.timestamp.higher]))} - UTC`;\n        const calculateEffectiveFee = amountFormatterSimple(existBlock.feeMultiplier * transaction.data.size);\n        effectiveFee = getDataPart(calculateEffectiveFee, 6);\n        console.log('Effective fee ---> ', transaction.effectiveFee);\n      } else {\n        dataBridge.getBlockInfo(height).subscribe(\n          next => {\n            console.log('Http', next);\n            dataBridge.validateBlock(next);\n            timestamp = `${dateFormatUTC(next.timestamp)} - UTC`;\n            const calculateEffectiveFee = amountFormatterSimple(next.feeMultiplier * transaction.data.size);\n            effectiveFee = getDataPart(calculateEffectiveFee, 6);\n            console.log('Effective fee ---> ', transaction.effectiveFee);\n          }\n        );\n      }\n    } else {\n      effectiveFee = getDataPart('0.00000', 6);\n    }\n  } else {\n    effectiveFee = getDataPart('0.00000', 6);\n  }\n  return {\n    timestamp, effectiveFee\n  };\n}*/\n\nconst amountFormatter = (amountParam, manualDivisibility = 0) => {\n  // console.log('amountParam', amountParam);\n  // const divisibility = (manualDivisibility === 0) ? manualDivisibility : mosaic.properties.divisibility;\n  // console.log('divisibility', divisibility);\n  const amountDivisibility = Number(amountParam / Math.pow(10, manualDivisibility));\n  // console.log('amountDivisibility', amountDivisibility);\n  const amountFormatter = amountDivisibility.toLocaleString('en-us', { minimumFractionDigits: manualDivisibility });\n  // console.log('amountFormatter', amountFormatter);\n  return amountFormatter;\n}\n\nconst transactions = Object(vue__WEBPACK_IMPORTED_MODULE_0__[\"readonly\"])({\n  arraTypeTransaction,\n  formatTransaction,\n  dateFormatUTC,\n  amountFormatterSimple,\n  getNameTypeTransaction,\n  getDataPart,\n  getAmount,\n  getLockFundAmount,\n  formatAggregateBondedTransaction,\n  amountFormatter,\n  getAccountsInfoTiedMultiSig,\n});\n\n//# sourceURL=webpack:///./src/util/transactions.js?");

/***/ })

}]);